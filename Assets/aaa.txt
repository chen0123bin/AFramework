


New Chat
Leaderboard
Today
请帮我开发一套完整的Unity3D资源管理系统，命名为LWAssets，专门用于帮助游戏研发团队实现快速部署和高效交付游戏产品。 该系统需要满足以下具体功能需求： **1. 多种运行模式支持**
More
Yesterday
我21年买的房子249万，当时首付了30%，房贷有176万。已经还了55个月了，目前房贷还剩160，月供7800，现在房子只能卖135万，目前房价还在下降趋势。这套房子是卖了合适，还是继续还贷合适。
More
Older
我想要写一个Unity脚本，脚本的功能可以控制物体下面的子物体全部规则的散开，而是规则化、可控的子物体散开，用于展示模型的层级结构，脚本专门实现这种结构化散开效果，支持多种规则排布子物体，可自定义散开
More
帮我开发一套用于Unity3D的资源管理系统 LWAssets，用于帮助研发团队快速部署和交付游戏。 可以满足以下任何需求： 多种运行模式：编辑器模拟、离线、联机、WebGL 灵活的分包策略：支持按标
More
帮我开发一套用于Unity3D的资源管理系统，用于帮助研发团队快速部署和交付游戏。 可以满足以下任何需求： 我想发布一个不包含任何游戏资源的安装包，然后玩家边玩边下载。 我想发布一个可以保证前期体验的
More
你知道极品采花郎这个游戏吗
More
帮我开发一套用于Unity3D的资源管理系统，用于帮助研发团队快速部署和交付游戏。 可以满足以下任何需求： 我想发布一个不包含任何游戏资源的安装包，然后玩家边玩边下载。（异步使用UniTask） 我想
More
帮我开发一套用于Unity3D的资源管理系统，用于帮助研发团队快速部署和交付游戏。 可以满足以下任何需求： 我想发布一个不包含任何游戏资源的安装包，然后玩家边玩边下载。 我想发布一个可以保证前期体验的
More
这是一个书籍三维模型的贴图，帮我不改变UV的情况下修改贴图的风格
More
设计和创建一个像 Windows 操作系统一样的 Web 操作系统，具有文本编辑器、带有 Python 和代码编辑器的终端以及可以播放的游戏、任务管理器、绘画、视频编辑器和所有重要的 Windows
More
编写一个Unity的Animation（不是Animator）动画控制脚本，可以切换动画，可以顺播、倒播、暂停
More
帮我设计一套Unity步骤管理系统，系统可以前进后退，跳转指定步骤，逐过程到指定步骤，步骤可以分为触发器、控制器，触发器包含鼠标点击三维物体触发、数值达到一定数量触发等，控制器包含播放音频、三维物体移
More
帮我设计一套Unity步骤管理系统，系统可以前进后退，步骤可以分为触发器、控制器，触发器包含鼠标点击三维物体触发、数值达到一定数量触发等，控制器包含播放音频、三维物体移动、三维物体显示隐藏。整个系统需
More
编写一个unity脚本，按住鼠标左键可以移动3d物体
More
生成一个三维爱心网页
More


chenbin19920123@gmail.com
Terms of Use
Privacy Policy
Cookies

Direct Chat


claude-opus-4-5-20251101

claude-opus-4-5-20251101
18. 编辑器 - 构建系统（续）
csharp

// Editor/Build/LWAssetsBuildPipeline.cs (续)
        /// <summary>
        /// 按文件夹分包
        /// </summary>
        private static List<AssetBundleBuild> PackageByFolder(PackageRule rule, List<string> assets)
        {
            var builds = new List<AssetBundleBuild>();
            var folderGroups = new Dictionary<string, List<string>>();
            
            foreach (var asset in assets)
            {
                var folder = Path.GetDirectoryName(asset).Replace("\\", "/");
                var relativePath = folder.Replace(rule.FolderPath.Replace("\\", "/"), "").Trim('/');
                
                if (string.IsNullOrEmpty(relativePath))
                {
                    relativePath = Path.GetFileName(rule.FolderPath);
                }
                
                if (!folderGroups.ContainsKey(relativePath))
                {
                    folderGroups[relativePath] = new List<string>();
                }
                folderGroups[relativePath].Add(asset);
            }
            
            foreach (var group in folderGroups)
            {
                var bundleName = $"{rule.Name}_{group.Key}".ToLower().Replace("/", "_").Replace(" ", "_");
                builds.Add(new AssetBundleBuild
                {
                    assetBundleName = bundleName,
                    assetNames = group.Value.ToArray()
                });
            }
            
            return builds;
        }
        
        /// <summary>
        /// 按文件分包
        /// </summary>
        private static List<AssetBundleBuild> PackageByFile(PackageRule rule, List<string> assets)
        {
            var builds = new List<AssetBundleBuild>();
            
            foreach (var asset in assets)
            {
                var fileName = Path.GetFileNameWithoutExtension(asset);
                var bundleName = $"{rule.Name}_{fileName}".ToLower().Replace(" ", "_");
                
                builds.Add(new AssetBundleBuild
                {
                    assetBundleName = bundleName,
                    assetNames = new[] { asset }
                });
            }
            
            return builds;
        }
        
        /// <summary>
        /// 按大小分包
        /// </summary>
        private static List<AssetBundleBuild> PackageBySize(PackageRule rule, List<string> assets)
        {
            var builds = new List<AssetBundleBuild>();
            var currentAssets = new List<string>();
            long currentSize = 0;
            int bundleIndex = 0;
            
            // 按文件大小排序
            var sortedAssets = assets
                .Select(a => new { Path = a, Size = new FileInfo(a).Length })
                .OrderByDescending(a => a.Size)
                .ToList();
            
            foreach (var asset in sortedAssets)
            {
                // 如果当前bundle超过大小限制，创建新bundle
                if (currentSize + asset.Size > rule.MaxBundleSize && currentAssets.Count > 0)
                {
                    builds.Add(new AssetBundleBuild
                    {
                        assetBundleName = $"{rule.Name}_{bundleIndex}".ToLower(),
                        assetNames = currentAssets.ToArray()
                    });
                    
                    currentAssets.Clear();
                    currentSize = 0;
                    bundleIndex++;
                }
                
                currentAssets.Add(asset.Path);
                currentSize += asset.Size;
            }
            
            // 剩余资源
            if (currentAssets.Count > 0)
            {
                builds.Add(new AssetBundleBuild
                {
                    assetBundleName = $"{rule.Name}_{bundleIndex}".ToLower(),
                    assetNames = currentAssets.ToArray()
                });
            }
            
            return builds;
        }
        
        /// <summary>
        /// 收集Shader
        /// </summary>
        private static AssetBundleBuild CollectShaders(LWAssetsBuildConfig config)
        {
            var shaderPaths = new List<string>();
            
            // 收集所有Shader
            var guids = AssetDatabase.FindAssets("t:Shader");
            foreach (var guid in guids)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                // 排除内置Shader和Package中的Shader
                if (!path.StartsWith("Assets/")) continue;
                shaderPaths.Add(path);
            }
            
            // 收集ShaderVariantCollection
            foreach (var svcPath in config.ShaderVariantCollections)
            {
                if (File.Exists(svcPath))
                {
                    shaderPaths.Add(svcPath);
                }
            }
            
            return new AssetBundleBuild
            {
                assetBundleName = config.ShaderBundleName,
                assetNames = shaderPaths.ToArray()
            };
        }
        
        /// <summary>
        /// 生成清单文件
        /// </summary>
        private static BundleManifest GenerateManifest(LWAssetsBuildConfig config, 
            AssetBundleManifest unityManifest, string outputPath)
        {
            var manifest = new BundleManifest
            {
                Version = PlayerSettings.bundleVersion,
                BuildTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
                Platform = LWAssetsConfig.GetPlatformName()
            };
            
            var allBundles = unityManifest.GetAllAssetBundles();
            
            foreach (var bundleName in allBundles)
            {
                var bundlePath = Path.Combine(outputPath, bundleName);
                var fileInfo = new FileInfo(bundlePath);
                
                var bundleInfo = new BundleInfo
                {
                    BundleName = bundleName,
                    Hash = unityManifest.GetAssetBundleHash(bundleName).ToString(),
                    CRC = HashUtility.ComputeFileCRC32(bundlePath),
                    Size = fileInfo.Length,
                    Dependencies = unityManifest.GetAllDependencies(bundleName).ToList()
                };
                
                // 获取Bundle中的资源
                var bundle = AssetBundle.LoadFromFile(bundlePath);
                if (bundle != null)
                {
                    bundleInfo.Assets = bundle.GetAllAssetNames().ToList();
                    bundle.Unload(false);
                }
                
                // 应用标签规则
                ApplyTagRules(config, bundleInfo);
                
                // 应用优先级
                var rule = config.PackageRules.FirstOrDefault(r => 
                    bundleName.StartsWith(r.Name.ToLower()));
                if (rule != null)
                {
                    bundleInfo.Priority = rule.Priority;
                    bundleInfo.Tags.AddRange(rule.Tags);
                }
                
                manifest.Bundles.Add(bundleInfo);
                
                // 添加资源信息
                foreach (var assetPath in bundleInfo.Assets)
                {
                    manifest.Assets.Add(new AssetInfo
                    {
                        AssetPath = assetPath,
                        BundleName = bundleName,
                        AssetType = AssetDatabase.GetMainAssetTypeAtPath(assetPath)?.Name ?? "Unknown"
                    });
                }
                
                // 重命名Bundle文件（添加Hash）
                var newBundlePath = Path.Combine(outputPath, bundleInfo.GetFileName());
                if (File.Exists(newBundlePath))
                {
                    File.Delete(newBundlePath);
                }
                File.Move(bundlePath, newBundlePath);
            }
            
            // 处理原始文件
            ProcessRawFiles(config, manifest, outputPath);
            
            // 保存清单
            var manifestPath = Path.Combine(outputPath, "manifest.json");
            File.WriteAllText(manifestPath, manifest.ToJson());
            
            manifest.BuildIndex();
            return manifest;
        }
        
        /// <summary>
        /// 处理原始文件
        /// </summary>
        private static void ProcessRawFiles(LWAssetsBuildConfig config, BundleManifest manifest, string outputPath)
        {
            foreach (var rule in config.PackageRules.Where(r => r.Strategy == PackageStrategy.RawFile))
            {
                if (string.IsNullOrEmpty(rule.FolderPath)) continue;
                if (!Directory.Exists(rule.FolderPath)) continue;
                
                var files = Directory.GetFiles(rule.FolderPath, rule.FilePattern, SearchOption.AllDirectories)
                    .Where(f => !f.EndsWith(".meta"))
                    .Select(f => f.Replace("\\", "/"))
                    .ToList();
                
                foreach (var file in files)
                {
                    var fileName = Path.GetFileName(file);
                    var hash = HashUtility.ComputeFileMD5(file);
                    var fileInfo = new FileInfo(file);
                    
                    var bundleInfo = new BundleInfo
                    {
                        BundleName = $"raw_{fileName}",
                        Hash = hash,
                        Size = fileInfo.Length,
                        IsRawFile = true,
                        Priority = rule.Priority,
                        Tags = new List<string>(rule.Tags),
                        Assets = new List<string> { file }
                    };
                    
                    manifest.Bundles.Add(bundleInfo);
                    manifest.Assets.Add(new AssetInfo
                    {
                        AssetPath = file,
                        BundleName = bundleInfo.BundleName,
                        IsRawFile = true
                    });
                    
                    // 复制原始文件到输出目录
                    var destPath = Path.Combine(outputPath, bundleInfo.GetFileName());
                    File.Copy(file, destPath, true);
                }
            }
        }
        
        /// <summary>
        /// 应用标签规则
        /// </summary>
        private static void ApplyTagRules(LWAssetsBuildConfig config, BundleInfo bundleInfo)
        {
            foreach (var rule in config.TagRules)
            {
                foreach (var asset in bundleInfo.Assets)
                {
                    if (asset.StartsWith(rule.FolderPath.Replace("\\", "/")))
                    {
                        foreach (var tag in rule.Tags)
                        {
                            if (!bundleInfo.Tags.Contains(tag))
                            {
                                bundleInfo.Tags.Add(tag);
                            }
                        }
                    }
                }
            }
        }
        
        /// <summary>
        /// 生成版本文件
        /// </summary>
        private static void GenerateVersionFile(LWAssetsBuildConfig config, 
            BundleManifest manifest, string outputPath)
        {
            var manifestPath = Path.Combine(outputPath, "manifest.json");
            var manifestHash = HashUtility.ComputeFileMD5(manifestPath);
            var manifestSize = new FileInfo(manifestPath).Length;
            
            var version = new VersionInfo
            {
                Version = PlayerSettings.bundleVersion,
                ManifestHash = manifestHash,
                ManifestSize = manifestSize,
                BuildTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
                MinAppVersion = Application.version,
                ForceUpdate = false
            };
            
            var versionPath = Path.Combine(outputPath, "version.json");
            File.WriteAllText(versionPath, JsonUtility.ToJson(version, true));
        }
        
        /// <summary>
        /// 清理输出目录
        /// </summary>
        private static void CleanupOutputPath(string outputPath, BundleManifest manifest)
        {
            var validFiles = new HashSet<string>();
            validFiles.Add("manifest.json");
            validFiles.Add("version.json");
            
            foreach (var bundle in manifest.Bundles)
            {
                validFiles.Add(bundle.GetFileName());
            }
            
            foreach (var file in Directory.GetFiles(outputPath))
            {
                var fileName = Path.GetFileName(file);
                if (!validFiles.Contains(fileName))
                {
                    File.Delete(file);
                }
            }
        }
        
        /// <summary>
        /// 生成构建报告
        /// </summary>
        private static void GenerateBuildReport(LWAssetsBuildConfig config, 
            BundleManifest manifest, string outputPath)
        {
            var report = new System.Text.StringBuilder();
            
            report.AppendLine("=== LWAssets Build Report ===");
            report.AppendLine($"Build Time: {DateTime.Now}");
            report.AppendLine($"Platform: {config.BuildTarget}");
            report.AppendLine($"Version: {PlayerSettings.bundleVersion}");
            report.AppendLine();
            
            report.AppendLine("=== Bundle Summary ===");
            report.AppendLine($"Total Bundles: {manifest.Bundles.Count}");
            report.AppendLine($"Total Size: {FileUtility.FormatFileSize(manifest.GetTotalSize())}");
            report.AppendLine($"Total Assets: {manifest.Assets.Count}");
            report.AppendLine();
            
            report.AppendLine("=== Bundle Details ===");
            foreach (var bundle in manifest.Bundles.OrderByDescending(b => b.Size))
            {
                report.AppendLine($"  {bundle.BundleName}");
                report.AppendLine($"    Size: {FileUtility.FormatFileSize(bundle.Size)}");
                report.AppendLine($"    Assets: {bundle.Assets.Count}");
                report.AppendLine($"    Dependencies: {bundle.Dependencies.Count}");
                report.AppendLine($"    Tags: {string.Join(", ", bundle.Tags)}");
            }
            
            report.AppendLine();
            report.AppendLine("=== Tag Summary ===");
            var tagGroups = manifest.Bundles
                .SelectMany(b => b.Tags.Select(t => new { Tag = t, Bundle = b }))
                .GroupBy(x => x.Tag);
            
            foreach (var group in tagGroups)
            {
                var totalSize = group.Sum(x => x.Bundle.Size);
                report.AppendLine($"  {group.Key}: {group.Count()} bundles, {FileUtility.FormatFileSize(totalSize)}");
            }
            
            var reportPath = Path.Combine(outputPath, "build_report.txt");
            File.WriteAllText(reportPath, report.ToString());
            
            Debug.Log($"[LWAssets] Build report saved to: {reportPath}");
        }
        
        /// <summary>
        /// 获取输出路径
        /// </summary>
        private static string GetOutputPath(LWAssetsBuildConfig config)
        {
            var platform = config.BuildTarget switch
            {
                BuildTarget.Android => "Android",
                BuildTarget.iOS => "iOS",
                BuildTarget.WebGL => "WebGL",
                BuildTarget.StandaloneWindows64 => "Windows",
                BuildTarget.StandaloneOSX => "MacOS",
                BuildTarget.StandaloneLinux64 => "Linux",
                _ => "Unknown"
            };
            
            return Path.Combine(Application.dataPath, "..", config.OutputPath, platform);
        }
    }
}
#endif
19. 编辑器 - Shader处理器
csharp

// Editor/Build/ShaderProcessor.cs
#if UNITY_EDITOR
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;

namespace LWAssets.Editor
{
    /// <summary>
    /// Shader处理器
    /// </summary>
    public static class ShaderProcessor
    {
        /// <summary>
        /// 收集项目中使用的所有Shader变体
        /// </summary>
        [MenuItem("LWAssets/Shader/Collect Shader Variants")]
        public static void CollectShaderVariants()
        {
            var svc = new ShaderVariantCollection();
            var materials = CollectAllMaterials();
            
            foreach (var material in materials)
            {
                if (material.shader == null) continue;
                
                try
                {
                    // 获取Material使用的PassType
                    var passTypes = GetMaterialPassTypes(material);
                    
                    foreach (var passType in passTypes)
                    {
                        var keywords = material.shaderKeywords;
                        var variant = new ShaderVariantCollection.ShaderVariant(
                            material.shader, passType, keywords);
                        
                        if (!svc.Contains(variant))
                        {
                            svc.Add(variant);
                        }
                    }
                }
                catch
                {
                    // 某些Shader可能不支持
                }
            }
            
            // 保存
            var path = "Assets/LWAssets/ShaderVariants.shadervariants";
            AssetDatabase.CreateAsset(svc, path);
            AssetDatabase.SaveAssets();
            
            Debug.Log($"[LWAssets] Collected {svc.variantCount} shader variants to {path}");
        }
        
        /// <summary>
        /// 获取所有Material
        /// </summary>
        private static List<Material> CollectAllMaterials()
        {
            var materials = new List<Material>();
            
            // 从Prefab中收集
            var prefabGuids = AssetDatabase.FindAssets("t:Prefab");
            foreach (var guid in prefabGuids)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                var prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);
                if (prefab == null) continue;
                
                var renderers = prefab.GetComponentsInChildren<Renderer>(true);
                foreach (var renderer in renderers)
                {
                    materials.AddRange(renderer.sharedMaterials.Where(m => m != null));
                }
            }
            
            // 从Material资源中收集
            var materialGuids = AssetDatabase.FindAssets("t:Material");
            foreach (var guid in materialGuids)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                if (!path.StartsWith("Assets/")) continue;
                
                var material = AssetDatabase.LoadAssetAtPath<Material>(path);
                if (material != null)
                {
                    materials.Add(material);
                }
            }
            
            return materials.Distinct().ToList();
        }
        
        /// <summary>
        /// 获取Material的PassType
        /// </summary>
        private static List<PassType> GetMaterialPassTypes(Material material)
        {
            var passTypes = new List<PassType>();
            
            // 常见的PassType
            passTypes.Add(PassType.Normal);
            passTypes.Add(PassType.ForwardBase);
            passTypes.Add(PassType.ForwardAdd);
            passTypes.Add(PassType.ShadowCaster);
            
            // URP特有的Pass
            passTypes.Add(PassType.ScriptableRenderPipeline);
            passTypes.Add(PassType.ScriptableRenderPipelineDefaultUnlit);
            
            return passTypes;
        }
        
        /// <summary>
        /// 分析Shader使用情况
        /// </summary>
        [MenuItem("LWAssets/Shader/Analyze Shader Usage")]
        public static void AnalyzeShaderUsage()
        {
            var shaderUsage = new Dictionary<Shader, int>();
            var materials = CollectAllMaterials();
            
            foreach (var material in materials)
            {
                if (material.shader == null) continue;
                
                if (!shaderUsage.ContainsKey(material.shader))
                {
                    shaderUsage[material.shader] = 0;
                }
                shaderUsage[material.shader]++;
            }
            
            // 输出报告
            var report = new System.Text.StringBuilder();
            report.AppendLine("=== Shader Usage Report ===\n");
            
            foreach (var kvp in shaderUsage.OrderByDescending(x => x.Value))
            {
                var shaderPath = AssetDatabase.GetAssetPath(kvp.Key);
                var isBuiltin = string.IsNullOrEmpty(shaderPath) || shaderPath.StartsWith("Resources/");
                
                report.AppendLine($"{kvp.Key.name}");
                report.AppendLine($"  Usage Count: {kvp.Value}");
                report.AppendLine($"  Type: {(isBuiltin ? "Built-in" : "Custom")}");
                if (!isBuiltin)
                {
                    report.AppendLine($"  Path: {shaderPath}");
                }
                report.AppendLine();
            }
            
            var reportPath = "Assets/LWAssets/shader_usage_report.txt";
            File.WriteAllText(reportPath, report.ToString());
            AssetDatabase.Refresh();
            
            Debug.Log($"[LWAssets] Shader usage report saved to {reportPath}");
        }
        
        /// <summary>
        /// 检查Shader兼容性
        /// </summary>
        [MenuItem("LWAssets/Shader/Check Shader Compatibility")]
        public static void CheckShaderCompatibility()
        {
            var issues = new List<string>();
            
            var shaderGuids = AssetDatabase.FindAssets("t:Shader");
            foreach (var guid in shaderGuids)
            {
                var path = AssetDatabase.GUIDToAssetPath(guid);
                if (!path.StartsWith("Assets/")) continue;
                
                var shader = AssetDatabase.LoadAssetAtPath<Shader>(path);
                if (shader == null) continue;
                
                // 检查是否支持目标平台
                if (!shader.isSupported)
                {
                    issues.Add($"[Unsupported] {path}");
                }
                
                // 检查编译错误
                var shaderContent = File.ReadAllText(path);
                if (shaderContent.Contains("#error"))
                {
                    issues.Add($"[Has #error] {path}");
                }
            }
            
            if (issues.Count > 0)
            {
                Debug.LogWarning($"[LWAssets] Found {issues.Count} shader issues:\n" + 
                    string.Join("\n", issues));
            }
            else
            {
                Debug.Log("[LWAssets] No shader compatibility issues found.");
            }
        }
    }
}
#endif
20. 编辑器 - 资源分析器
csharp

// Editor/Inspector/AssetAnalyzer.cs
#if UNITY_EDITOR
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace LWAssets.Editor
{
    /// <summary>
    /// 资源分析器
    /// </summary>
    public class AssetAnalyzer : EditorWindow
    {
        private Vector2 _scrollPos;
        private string _searchPath = "Assets";
        private List<AssetAnalysisResult> _results = new List<AssetAnalysisResult>();
        private bool _showDuplicates = true;
        private bool _showLargeFiles = true;
        private bool _showMissingRefs = true;
        private long _largeFileThreshold = 10 * 1024 * 1024; // 10MB
        
        [MenuItem("LWAssets/Tools/Asset Analyzer")]
        public static void ShowWindow()
        {
            GetWindow<AssetAnalyzer>("Asset Analyzer");
        }
        
        private void OnGUI()
        {
            EditorGUILayout.BeginHorizontal();
            _searchPath = EditorGUILayout.TextField("Search Path", _searchPath);
            if (GUILayout.Button("Browse", GUILayout.Width(60)))
            {
                var path = EditorUtility.OpenFolderPanel("Select Folder", "Assets", "");
                if (!string.IsNullOrEmpty(path))
                {
                    _searchPath = "Assets" + path.Substring(Application.dataPath.Length);
                }
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.Space();
            
            EditorGUILayout.BeginHorizontal();
            _showDuplicates = EditorGUILayout.Toggle("Show Duplicates", _showDuplicates);
            _showLargeFiles = EditorGUILayout.Toggle("Show Large Files", _showLargeFiles);
            _showMissingRefs = EditorGUILayout.Toggle("Show Missing Refs", _showMissingRefs);
            EditorGUILayout.EndHorizontal();
            
            _largeFileThreshold = EditorGUILayout.LongField("Large File Threshold (bytes)", _largeFileThreshold);
            
            EditorGUILayout.Space();
            
            if (GUILayout.Button("Analyze", GUILayout.Height(30)))
            {
                AnalyzeAssets();
            }
            
            EditorGUILayout.Space();
            EditorGUILayout.LabelField($"Found {_results.Count} issues", EditorStyles.boldLabel);
            
            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos);
            
            foreach (var result in _results)
            {
                DrawAnalysisResult(result);
            }
            
            EditorGUILayout.EndScrollView();
        }
        
        private void AnalyzeAssets()
        {
            _results.Clear();
            
            EditorUtility.DisplayProgressBar("Analyzing", "Collecting assets...", 0);
            
            try
            {
                var allAssets = AssetDatabase.FindAssets("", new[] { _searchPath })
                    .Select(AssetDatabase.GUIDToAssetPath)
                    .Where(p => !AssetDatabase.IsValidFolder(p))
                    .ToList();
                
                // 检查重复资源
                if (_showDuplicates)
                {
                    EditorUtility.DisplayProgressBar("Analyzing", "Checking duplicates...", 0.25f);
                    CheckDuplicates(allAssets);
                }
                
                // 检查大文件
                if (_showLargeFiles)
                {
                    EditorUtility.DisplayProgressBar("Analyzing", "Checking large files...", 0.5f);
                    CheckLargeFiles(allAssets);
                }
                
                // 检查丢失引用
                if (_showMissingRefs)
                {
                    EditorUtility.DisplayProgressBar("Analyzing", "Checking missing references...", 0.75f);
                    CheckMissingReferences(allAssets);
                }
            }
            finally
            {
                EditorUtility.ClearProgressBar();
            }
        }
        
        private void CheckDuplicates(List<string> assets)
        {
            var hashGroups = new Dictionary<string, List<string>>();
            
            foreach (var path in assets)
            {
                if (path.EndsWith(".cs") || path.EndsWith(".shader")) continue;
                
                var hash = HashUtility.ComputeFileMD5(path);
                if (hash == null) continue;
                
                if (!hashGroups.ContainsKey(hash))
                {
                    hashGroups[hash] = new List<string>();
                }
                hashGroups[hash].Add(path);
            }
            
            foreach (var group in hashGroups.Where(g => g.Value.Count > 1))
            {
                _results.Add(new AssetAnalysisResult
                {
                    Type = AnalysisIssueType.Duplicate,
                    AssetPaths = group.Value,
                    Message = $"Found {group.Value.Count} duplicate files"
                });
            }
        }
        
        private void CheckLargeFiles(List<string> assets)
        {
            foreach (var path in assets)
            {
                var fileInfo = new System.IO.FileInfo(path);
                if (fileInfo.Length > _largeFileThreshold)
                {
                    _results.Add(new AssetAnalysisResult
                    {
                        Type = AnalysisIssueType.LargeFile,
                        AssetPaths = new List<string> { path },
                        Message = $"File size: {FileUtility.FormatFileSize(fileInfo.Length)}"
                    });
                }
            }
        }
        
        private void CheckMissingReferences(List<string> assets)
        {
            var prefabPaths = assets.Where(p => p.EndsWith(".prefab")).ToList();
            
            foreach (var path in prefabPaths)
            {
                var prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);
                if (prefab == null) continue;
                
                var missingRefs = FindMissingReferences(prefab);
                if (missingRefs.Count > 0)
                {
                    _results.Add(new AssetAnalysisResult
                    {
                        Type = AnalysisIssueType.MissingReference,
                        AssetPaths = new List<string> { path },
                        Message = $"Missing references: {string.Join(", ", missingRefs)}"
                    });
                }
            }
        }
        
        private List<string> FindMissingReferences(GameObject obj)
        {
            var missing = new List<string>();
            
            var components = obj.GetComponentsInChildren<Component>(true);
            foreach (var component in components)
            {
                if (component == null)
                {
                    missing.Add("Missing Script");
                    continue;
                }
                
                var so = new SerializedObject(component);
                var sp = so.GetIterator();
                
                while (sp.NextVisible(true))
                {
                    if (sp.propertyType == SerializedPropertyType.ObjectReference &&
                        sp.objectReferenceValue == null &&
                        sp.objectReferenceInstanceIDValue != 0)
                    {
                        missing.Add(sp.propertyPath);
                    }
                }
            }
            
            return missing;
        }
        
        private void DrawAnalysisResult(AssetAnalysisResult result)
        {
            EditorGUILayout.BeginVertical("box");
            
            // 图标和类型
            var icon = result.Type switch
            {
                AnalysisIssueType.Duplicate => EditorGUIUtility.IconContent("console.warnicon.sml"),
                AnalysisIssueType.LargeFile => EditorGUIUtility.IconContent("console.infoicon.sml"),
                AnalysisIssueType.MissingReference => EditorGUIUtility.IconContent("console.erroricon.sml"),
                _ => null
            };
            
            EditorGUILayout.BeginHorizontal();
            if (icon != null)
            {
                GUILayout.Label(icon, GUILayout.Width(20), GUILayout.Height(20));
            }
            EditorGUILayout.LabelField($"[{result.Type}] {result.Message}", EditorStyles.boldLabel);
            EditorGUILayout.EndHorizontal();
            
            // 资源列表
            foreach (var path in result.AssetPaths)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.ObjectField(AssetDatabase.LoadAssetAtPath<Object>(path), 
                    typeof(Object), false);
                
                if (GUILayout.Button("Select", GUILayout.Width(60)))
                {
                    Selection.activeObject = AssetDatabase.LoadAssetAtPath<Object>(path);
                    EditorGUIUtility.PingObject(Selection.activeObject);
                }
                EditorGUILayout.EndHorizontal();
            }
            
            EditorGUILayout.EndVertical();
            EditorGUILayout.Space(5);
        }
    }
    
    public enum AnalysisIssueType
    {
        Duplicate,
        LargeFile,
        MissingReference
    }
    
    public class AssetAnalysisResult
    {
        public AnalysisIssueType Type;
        public List<string> AssetPaths;
        public string Message;
    }
}
#endif
21. 编辑器 - Bundle查看器
csharp

// Editor/Inspector/BundleViewer.cs
#if UNITY_EDITOR
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace LWAssets.Editor
{
    /// <summary>
    /// Bundle查看器
    /// </summary>
    public class BundleViewer : EditorWindow
    {
        private Vector2 _bundleListScrollPos;
        private Vector2 _assetListScrollPos;
        private Vector2 _dependencyScrollPos;
        
        private BundleManifest _manifest;
        private string _manifestPath;
        private BundleInfo _selectedBundle;
        private string _searchText = "";
        private int _selectedTab;
        private readonly string[] _tabs = { "Bundles", "Assets", "Dependencies" };
        
        [MenuItem("LWAssets/Tools/Bundle Viewer")]
        public static void ShowWindow()
        {
            GetWindow<BundleViewer>("Bundle Viewer");
        }
        
        private void OnGUI()
        {
            DrawToolbar();
            
            if (_manifest == null)
            {
                EditorGUILayout.HelpBox("Load a manifest file to view bundles.", MessageType.Info);
                return;
            }
            
            _selectedTab = GUILayout.Toolbar(_selectedTab, _tabs);
            EditorGUILayout.Space();
            
            switch (_selectedTab)
            {
                case 0:
                    DrawBundleList();
                    break;
                case 1:
                    DrawAssetList();
                    break;
                case 2:
                    DrawDependencyGraph();
                    break;
            }
        }
        
        private void DrawToolbar()
        {
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            
            if (GUILayout.Button("Load Manifest", EditorStyles.toolbarButton, GUILayout.Width(100)))
            {
                var path = EditorUtility.OpenFilePanel("Select Manifest", 
                    Application.dataPath + "/../AssetBundles", "json");
                if (!string.IsNullOrEmpty(path))
                {
                    LoadManifest(path);
                }
            }
            
            if (GUILayout.Button("Refresh", EditorStyles.toolbarButton, GUILayout.Width(60)))
            {
                if (!string.IsNullOrEmpty(_manifestPath))
                {
                    LoadManifest(_manifestPath);
                }
            }
            
            GUILayout.FlexibleSpace();
            
            _searchText = EditorGUILayout.TextField(_searchText, EditorStyles.toolbarSearchField, 
                GUILayout.Width(200));
            
            if (GUILayout.Button("", GUI.skin.FindStyle("ToolbarSeachCancelButton")))
            {
                _searchText = "";
                GUI.FocusControl(null);
            }
            
            EditorGUILayout.EndHorizontal();
            
            // 显示清单信息
            if (_manifest != null)
            {
                EditorGUILayout.BeginHorizontal("box");
                EditorGUILayout.LabelField($"Version: {_manifest.Version}");
                EditorGUILayout.LabelField($"Platform: {_manifest.Platform}");
                EditorGUILayout.LabelField($"Bundles: {_manifest.Bundles.Count}");
                EditorGUILayout.LabelField($"Total Size: {FileUtility.FormatFileSize(_manifest.GetTotalSize())}");
                EditorGUILayout.EndHorizontal();
            }
        }
        
        private void LoadManifest(string path)
        {
            try
            {
                var json = File.ReadAllText(path);
                _manifest = BundleManifest.FromJson(json);
                _manifestPath = path;
                _selectedBundle = null;
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[LWAssets] Failed to load manifest: {ex.Message}");
            }
        }
        
        private void DrawBundleList()
        {
            EditorGUILayout.BeginHorizontal();
            
            // Bundle列表
            EditorGUILayout.BeginVertical("box", GUILayout.Width(position.width * 0.4f));
            EditorGUILayout.LabelField("Bundle List", EditorStyles.boldLabel);
            
            _bundleListScrollPos = EditorGUILayout.BeginScrollView(_bundleListScrollPos);
            
            var filteredBundles = _manifest.Bundles
                .Where(b => string.IsNullOrEmpty(_searchText) || 
                    b.BundleName.ToLower().Contains(_searchText.ToLower()))
                .OrderByDescending(b => b.Size);
            
            foreach (var bundle in filteredBundles)
            {
                var isSelected = _selectedBundle == bundle;
                var style = isSelected ? "selectionRect" : "box";
                
                EditorGUILayout.BeginHorizontal(style);
                
                EditorGUILayout.LabelField(bundle.BundleName, GUILayout.Width(150));
                EditorGUILayout.LabelField(FileUtility.FormatFileSize(bundle.Size), GUILayout.Width(80));
                EditorGUILayout.LabelField($"[{string.Join(",", bundle.Tags)}]");
                
                if (GUILayout.Button("Select", GUILayout.Width(50)))
                {
                    _selectedBundle = bundle;
                }
                
                EditorGUILayout.EndHorizontal();
            }
            
            EditorGUILayout.EndScrollView();
            EditorGUILayout.EndVertical();
            
            // Bundle详情
            EditorGUILayout.BeginVertical("box");
            EditorGUILayout.LabelField("Bundle Details", EditorStyles.boldLabel);
            
            if (_selectedBundle != null)
            {
                DrawBundleDetails(_selectedBundle);
            }
            else
            {
                EditorGUILayout.HelpBox("Select a bundle to view details.", MessageType.Info);
            }
            
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.EndHorizontal();
        }
        
        private void DrawBundleDetails(BundleInfo bundle)
        {
            EditorGUILayout.LabelField("Name", bundle.BundleName);
            EditorGUILayout.LabelField("Size", FileUtility.FormatFileSize(bundle.Size));
            EditorGUILayout.LabelField("Hash", bundle.Hash);
            EditorGUILayout.LabelField("CRC", bundle.CRC.ToString());
            EditorGUILayout.LabelField("Priority", bundle.Priority.ToString());
            EditorGUILayout.LabelField("Is Raw File", bundle.IsRawFile.ToString());
            EditorGUILayout.LabelField("Tags", string.Join(", ", bundle.Tags));
            
            EditorGUILayout.Space();
            EditorGUILayout.LabelField($"Dependencies ({bundle.Dependencies.Count})", EditorStyles.boldLabel);
            
            _dependencyScrollPos = EditorGUILayout.BeginScrollView(_dependencyScrollPos, GUILayout.MaxHeight(100));
            foreach (var dep in bundle.Dependencies)
            {
                EditorGUILayout.LabelField("  • " + dep);
            }
            EditorGUILayout.EndScrollView();
            
            EditorGUILayout.Space();
            EditorGUILayout.LabelField($"Assets ({bundle.Assets.Count})", EditorStyles.boldLabel);
            
            _assetListScrollPos = EditorGUILayout.BeginScrollView(_assetListScrollPos);
            foreach (var asset in bundle.Assets)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField(asset);
                
                if (GUILayout.Button("Ping", GUILayout.Width(40)))
                {
                    var obj = AssetDatabase.LoadAssetAtPath<Object>(asset);
                    if (obj != null)
                    {
                        EditorGUIUtility.PingObject(obj);
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.EndScrollView();
        }
        
        private void DrawAssetList()
        {
            EditorGUILayout.LabelField($"All Assets ({_manifest.Assets.Count})", EditorStyles.boldLabel);
            
            _assetListScrollPos = EditorGUILayout.BeginScrollView(_assetListScrollPos);
            
            var filteredAssets = _manifest.Assets
                .Where(a => string.IsNullOrEmpty(_searchText) || 
                    a.AssetPath.ToLower().Contains(_searchText.ToLower()));
            
            EditorGUILayout.BeginHorizontal("box");
            EditorGUILayout.LabelField("Asset Path", EditorStyles.boldLabel, GUILayout.Width(300));
            EditorGUILayout.LabelField("Type", EditorStyles.boldLabel, GUILayout.Width(100));
            EditorGUILayout.LabelField("Bundle", EditorStyles.boldLabel);
            EditorGUILayout.EndHorizontal();
            
            foreach (var asset in filteredAssets)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField(asset.AssetPath, GUILayout.Width(300));
                EditorGUILayout.LabelField(asset.AssetType, GUILayout.Width(100));
                EditorGUILayout.LabelField(asset.BundleName);
                
                if (GUILayout.Button("Ping", GUILayout.Width(40)))
                {
                    var obj = AssetDatabase.LoadAssetAtPath<Object>(asset.AssetPath);
                    if (obj != null)
                    {
                        EditorGUIUtility.PingObject(obj);
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
            
            EditorGUILayout.EndScrollView();
        }
        
        private void DrawDependencyGraph()
        {
            EditorGUILayout.LabelField("Dependency Analysis", EditorStyles.boldLabel);
            EditorGUILayout.Space();
            
            // 找出被依赖最多的Bundle
            var dependencyCount = new Dictionary<string, int>();
            foreach (var bundle in _manifest.Bundles)
            {
                foreach (var dep in bundle.Dependencies)
                {
                    if (!dependencyCount.ContainsKey(dep))
                    {
                        dependencyCount[dep] = 0;
                    }
                    dependencyCount[dep]++;
                }
            }
            
            EditorGUILayout.LabelField("Most Depended Bundles:", EditorStyles.boldLabel);
            
            var topDepended = dependencyCount
                .OrderByDescending(x => x.Value)
                .Take(10);
            
            foreach (var kvp in topDepended)
            {
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField(kvp.Key);
                EditorGUILayout.LabelField($"Depended by {kvp.Value} bundles", GUILayout.Width(150));
                EditorGUILayout.EndHorizontal();
            }
            
            EditorGUILayout.Space();
            
            // 循环依赖检测
            EditorGUILayout.LabelField("Circular Dependencies:", EditorStyles.boldLabel);
            var circularDeps = FindCircularDependencies();
            
            if (circularDeps.Count == 0)
            {
                EditorGUILayout.HelpBox("No circular dependencies found.", MessageType.Info);
            }
            else
            {
                foreach (var cycle in circularDeps)
                {
                    EditorGUILayout.LabelField($"  • {string.Join(" -> ", cycle)}", EditorStyles.wordWrappedLabel);
                }
            }
        }
        
        private List<List<string>> FindCircularDependencies()
        {
            var cycles = new List<List<string>>();
            var visited = new HashSet<string>();
            var recStack = new HashSet<string>();
            var path = new List<string>();
            
            foreach (var bundle in _manifest.Bundles)
            {
                if (!visited.Contains(bundle.BundleName))
                {
                    FindCyclesDFS(bundle.BundleName, visited, recStack, path, cycles);
                }
            }
            
            return cycles;
        }
        
        private void FindCyclesDFS(string bundleName, HashSet<string> visited, 
            HashSet<string> recStack, List<string> path, List<List<string>> cycles)
        {
            visited.Add(bundleName);
            recStack.Add(bundleName);
            path.Add(bundleName);
            
            var bundle = _manifest.GetBundleInfo(bundleName);
            if (bundle != null)
            {
                foreach (var dep in bundle.Dependencies)
                {
                    if (!visited.Contains(dep))
                    {
                        FindCyclesDFS(dep, visited, recStack, path, cycles);
                    }
                    else if (recStack.Contains(dep))
                    {
                        // 找到循环
                        var cycleStart = path.IndexOf(dep);
                        var cycle = path.GetRange(cycleStart, path.Count - cycleStart);
                        cycle.Add(dep);
                        cycles.Add(cycle);
                    }
                }
            }
            
            path.RemoveAt(path.Count - 1);
            recStack.Remove(bundleName);
        }
    }
}
#endif
22. 编辑器 - 主窗口
csharp

// Editor/Window/LWAssetsWindow.cs
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using System.IO;

namespace LWAssets.Editor
{
    /// <summary>
    /// LWAssets主窗口
    /// </summary>
    public class LWAssetsWindow : EditorWindow
    {
        private int _selectedTab;
        private readonly string[] _tabs = { "Dashboard", "Build", "Settings" };
        
        private LWAssetsBuildConfig _buildConfig;
        private LWAssetsConfig _runtimeConfig;
        private Vector2 _scrollPos;
        
        [MenuItem("LWAssets/Dashboard")]
        public static void ShowWindow()
        {
            var window = GetWindow<LWAssetsWindow>("LWAssets");
            window.minSize = new Vector2(600, 400);
        }
        
        private void OnEnable()
        {
            LoadConfigs();
        }
        
        private void LoadConfigs()
        {
            // 加载构建配置
            var buildConfigGuids = AssetDatabase.FindAssets("t:LWAssetsBuildConfig");
            if (buildConfigGuids.Length > 0)
            {
                var path = AssetDatabase.GUIDToAssetPath(buildConfigGuids[0]);
                _buildConfig = AssetDatabase.LoadAssetAtPath<LWAssetsBuildConfig>(path);
            }
            
            // 加载运行时配置
            _runtimeConfig = LWAssetsConfig.Load();
        }
        
        private void OnGUI()
        {
            _selectedTab = GUILayout.Toolbar(_selectedTab, _tabs, GUILayout.Height(30));
            EditorGUILayout.Space();
            
            _scrollPos = EditorGUILayout.BeginScrollView(_scrollPos);
            
            switch (_selectedTab)
            {
                case 0:
                    DrawDashboard();
                    break;
                case 1:
                    DrawBuildPanel();
                    break;
                case 2:
                    DrawSettings();
                    break;
            }
            
            EditorGUILayout.EndScrollView();
        }
        
        private void DrawDashboard()
        {
            EditorGUILayout.LabelField("LWAssets Dashboard", EditorStyles.largeLabel);
            EditorGUILayout.Space();
            
            // 统计信息
            EditorGUILayout.BeginVertical("box");
            EditorGUILayout.LabelField("Project Statistics", EditorStyles.boldLabel);
            
            var assetCount = AssetDatabase.FindAssets("", new[] { "Assets" }).Length;
            var prefabCount = AssetDatabase.FindAssets("t:Prefab", new[] { "Assets" }).Length;
            var textureCount = AssetDatabase.FindAssets("t:Texture", new[] { "Assets" }).Length;
            var materialCount = AssetDatabase.FindAssets("t:Material", new[] { "Assets" }).Length;
            
            EditorGUILayout.LabelField($"Total Assets: {assetCount}");
            EditorGUILayout.LabelField($"Prefabs: {prefabCount}");
            EditorGUILayout.LabelField($"Textures: {textureCount}");
            EditorGUILayout.LabelField($"Materials: {materialCount}");
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.Space();
            
            // 快捷操作
            EditorGUILayout.BeginVertical("box");
            EditorGUILayout.LabelField("Quick Actions", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Build AssetBundles", GUILayout.Height(40)))
            {
                if (_buildConfig != null)
                {
                    LWAssetsBuildPipeline.Build(_buildConfig);
                }
                else
                {
                    Debug.LogError("[LWAssets] Build config not found!");
                }
            }
            
            if (GUILayout.Button("Open Bundle Viewer", GUILayout.Height(40)))
            {
                BundleViewer.ShowWindow();
            }
            
            if (GUILayout.Button("Analyze Assets", GUILayout.Height(40)))
            {
                AssetAnalyzer.ShowWindow();
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Collect Shader Variants", GUILayout.Height(40)))
            {
                ShaderProcessor.CollectShaderVariants();
            }
            
            if (GUILayout.Button("Clear Build Cache", GUILayout.Height(40)))
            {
                if (EditorUtility.DisplayDialog("Clear Build Cache", 
                    "Are you sure you want to clear the build cache?", "Yes", "No"))
                {
                    ClearBuildCache();
                }
            }
            
            if (GUILayout.Button("Open Build Folder", GUILayout.Height(40)))
            {
                if (_buildConfig != null)
                {
                    var path = Path.Combine(Application.dataPath, "..", _buildConfig.OutputPath);
                    if (Directory.Exists(path))
                    {
                        EditorUtility.RevealInFinder(path);
                    }
                }
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.EndVertical();
            
            EditorGUILayout.Space();
            
            // 构建历史
            DrawBuildHistory();
        }
        
        private void DrawBuildPanel()
        {
            EditorGUILayout.LabelField("Build Configuration", EditorStyles.largeLabel);
            EditorGUILayout.Space();
            
            // 构建配置对象
            EditorGUILayout.BeginHorizontal();
            _buildConfig = (LWAssetsBuildConfig)EditorGUILayout.ObjectField(
                "Build Config", _buildConfig, typeof(LWAssetsBuildConfig), false);
            
            if (GUILayout.Button("Create New", GUILayout.Width(100)))
            {
                CreateBuildConfig();
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.Space();
            
            if (_buildConfig != null)
            {
                var editor = UnityEditor.Editor.CreateEditor(_buildConfig);
                editor.OnInspectorGUI();
                
                EditorGUILayout.Space();
                
                // 构建按钮
                EditorGUILayout.BeginHorizontal();
                
                GUI.backgroundColor = Color.green;
                if (GUILayout.Button("Build", GUILayout.Height(40)))
                {
                    LWAssetsBuildPipeline.Build(_buildConfig);
                }
                GUI.backgroundColor = Color.white;
                
                if (GUILayout.Button("Build & Copy to StreamingAssets", GUILayout.Height(40)))
                {
                    LWAssetsBuildPipeline.Build(_buildConfig);
                    CopyToStreamingAssets();
                }
                
                EditorGUILayout.EndHorizontal();
            }
            else
            {
                EditorGUILayout.HelpBox("Please create or select a build configuration.", MessageType.Warning);
            }
        }
        
        private void DrawSettings()
        {
            EditorGUILayout.LabelField("Runtime Settings", EditorStyles.largeLabel);
            EditorGUILayout.Space();
            
            // 运行时配置对象
            EditorGUILayout.BeginHorizontal();
            _runtimeConfig = (LWAssetsConfig)EditorGUILayout.ObjectField(
                "Runtime Config", _runtimeConfig, typeof(LWAssetsConfig), false);
            
            if (GUILayout.Button("Create New", GUILayout.Width(100)))
            {
                CreateRuntimeConfig();
            }
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.Space();
            
            if (_runtimeConfig != null)
            {
                var editor = UnityEditor.Editor.CreateEditor(_runtimeConfig);
                editor.OnInspectorGUI();
            }
            else
            {
                EditorGUILayout.HelpBox("Runtime configuration not found. Please create one.", MessageType.Warning);
            }
        }
        
        private void DrawBuildHistory()
        {
            EditorGUILayout.BeginVertical("box");
            EditorGUILayout.LabelField("Recent Builds", EditorStyles.boldLabel);
            
            if (_buildConfig == null)
            {
                EditorGUILayout.LabelField("No build config selected.");
            }
            else
            {
                var buildPath = Path.Combine(Application.dataPath, "..", _buildConfig.OutputPath);
                
                if (Directory.Exists(buildPath))
                {
                    var platforms = Directory.GetDirectories(buildPath);
                    
                    foreach (var platform in platforms)
                    {
                        var manifestPath = Path.Combine(platform, "manifest.json");
                        if (File.Exists(manifestPath))
                        {
                            var json = File.ReadAllText(manifestPath);
                            var manifest = BundleManifest.FromJson(json);
                            
                            EditorGUILayout.BeginHorizontal();
                            EditorGUILayout.LabelField(Path.GetFileName(platform), GUILayout.Width(100));
                            EditorGUILayout.LabelField($"v{manifest.Version}", GUILayout.Width(80));
                            EditorGUILayout.LabelField(manifest.BuildTime, GUILayout.Width(150));
                            EditorGUILayout.LabelField($"{manifest.Bundles.Count} bundles", GUILayout.Width(100));
                            EditorGUILayout.LabelField(FileUtility.FormatFileSize(manifest.GetTotalSize()));
                            EditorGUILayout.EndHorizontal();
                        }
                    }
                }
                else
                {
                    EditorGUILayout.LabelField("No builds found.");
                }
            }
            
            EditorGUILayout.EndVertical();
        }
        
        private void CreateBuildConfig()
        {
            var path = EditorUtility.SaveFilePanelInProject(
                "Create Build Config", "LWAssetsBuildConfig", "asset", "");
            
            if (!string.IsNullOrEmpty(path))
            {
                var config = CreateInstance<LWAssetsBuildConfig>();
                AssetDatabase.CreateAsset(config, path);
                AssetDatabase.SaveAssets();
                _buildConfig = config;
            }
        }
        
        private void CreateRuntimeConfig()
        {
            var directory = "Assets/Resources/LWAssets";
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }
            
            var path = Path.Combine(directory, "LWAssetsConfig.asset");
            
            var config = CreateInstance<LWAssetsConfig>();
            AssetDatabase.CreateAsset(config, path);
            AssetDatabase.SaveAssets();
            _runtimeConfig = config;
        }
        
        private void ClearBuildCache()
        {
            if (_buildConfig != null)
            {
                var path = Path.Combine(Application.dataPath, "..", _buildConfig.OutputPath);
                if (Directory.Exists(path))
                {
                    Directory.Delete(path, true);
                    Debug.Log("[LWAssets] Build cache cleared.");
                }
            }
        }
        
        private void CopyToStreamingAssets()
        {
            if (_buildConfig == null) return;
            
            var sourcePath = Path.Combine(Application.dataPath, "..", 
                _buildConfig.OutputPath, LWAssetsConfig.GetPlatformName());
            var destPath = Path.Combine(Application.streamingAssetsPath, 
                _buildConfig.OutputPath, LWAssetsConfig.GetPlatformName());
            
            if (!Directory.Exists(sourcePath))
            {
                Debug.LogError("[LWAssets] Build output not found!");
                return;
            }
            
            if (Directory.Exists(destPath))
            {
                Directory.Delete(destPath, true);
            }
            
            FileUtility.CopyDirectory(sourcePath, destPath);
            AssetDatabase.Refresh();
            
            Debug.Log($"[LWAssets] Copied to StreamingAssets: {destPath}");
        }
    }
}
#endif
23. 使用示例
csharp

// Samples/Demo/LWAssetsDemo.cs
using System;
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.UI;

namespace LWAssets.Samples
{
    /// <summary>
    /// LWAssets使用示例
    /// </summary>
    public class LWAssetsDemo : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private Button _initButton;
        [SerializeField] private Button _loadAssetButton;
        [SerializeField] private Button _loadSceneButton;
        [SerializeField] private Button _downloadButton;
        [SerializeField] private Button _clearCacheButton;
        [SerializeField] private Text _statusText;
        [SerializeField] private Slider _progressSlider;
        [SerializeField] private Transform _spawnPoint;
        
        [Header("Test Assets")]
        [SerializeField] private string _testPrefabPath = "Assets/Prefabs/TestCube.prefab";
        [SerializeField] private string _testScenePath = "Assets/Scenes/TestScene.unity";
        [SerializeField] private string _testRawFilePath = "Assets/Config/game_config.json";
        
        private void Start()
        {
            SetupButtons();
        }
        
        private void SetupButtons()
        {
            _initButton?.onClick.AddListener(() => InitializeAsync().Forget());
            _loadAssetButton?.onClick.AddListener(() => LoadAssetAsync().Forget());
            _loadSceneButton?.onClick.AddListener(() => LoadSceneAsync().Forget());
            _downloadButton?.onClick.AddListener(() => DownloadAsync().Forget());
            _clearCacheButton?.onClick.AddListener(ClearCache);
        }
        
        /// <summary>
        /// 初始化LWAssets
        /// </summary>
        private async UniTaskVoid InitializeAsync()
        {
            try
            {
                UpdateStatus("Initializing LWAssets...");
                
                // 加载配置
                var config = LWAssetsConfig.Load();
                
                // 初始化
                await LWAssets.InitializeAsync(config);
                
                UpdateStatus($"Initialized! Mode: {LWAssets.CurrentPlayMode}");
            }
            catch (Exception ex)
            {
                UpdateStatus($"Init failed: {ex.Message}");
                Debug.LogException(ex);
            }
        }
        
        /// <summary>
        /// 加载资源示例
        /// </summary>
        private async UniTaskVoid LoadAssetAsync()
        {
            if (!LWAssets.IsInitialized)
            {
                UpdateStatus("Please initialize first!");
                return;
            }
            
            try
            {
                UpdateStatus("Loading prefab...");
                
                // 方式1：直接加载
                var prefab = await LWAssets.LoadAssetAsync<GameObject>(_testPrefabPath);
                if (prefab != null)
                {
                    var instance = Instantiate(prefab, _spawnPoint);
                    UpdateStatus($"Loaded: {prefab.name}");
                }
                
                // 方式2：使用句柄
                // var handle = await LWAssets.LoadAssetWithHandleAsync<GameObject>(_testPrefabPath);
                // if (handle.IsValid)
                // {
                //     var instance = Instantiate(handle.Asset, _spawnPoint);
                //     // 使用完毕后释放
                //     // handle.Release();
                // }
            }
            catch (Exception ex)
            {
                UpdateStatus($"Load failed: {ex.Message}");
                Debug.LogException(ex);
            }
        }
        
        /// <summary>
        /// 加载场景示例
        /// </summary>
        private async UniTaskVoid LoadSceneAsync()
        {
            if (!LWAssets.IsInitialized)
            {
                UpdateStatus("Please initialize first!");
                return;
            }
            
            try
            {
                UpdateStatus("Loading scene...");
                
                var handle = await LWAssets.LoadSceneAsync(
                    _testScenePath,
                    UnityEngine.SceneManagement.LoadSceneMode.Additive,
                    true);
                
                if (handle.IsValid)
                {
                    UpdateStatus($"Scene loaded: {handle.Scene.name}");
                }
                else if (handle.HasError)
                {
                    UpdateStatus($"Scene load error: {handle.Error.Message}");
                }
            }
            catch (Exception ex)
            {
                UpdateStatus($"Load failed: {ex.Message}");
                Debug.LogException(ex);
            }
        }
        
        /// <summary>
        /// 加载原始文件示例
        /// </summary>
        public async UniTask<string> LoadRawFileAsync()
        {
            if (!LWAssets.IsInitialized)
            {
                await LWAssets.InitializeAsync();
            }
            
            var text = await LWAssets.LoadRawFileTextAsync(_testRawFilePath);
            Debug.Log($"Raw file content: {text}");
            return text;
        }
        
        /// <summary>
        /// 下载资源示例
        /// </summary>
        private async UniTaskVoid DownloadAsync()
        {
            if (!LWAssets.IsInitialized)
            {
                UpdateStatus("Please initialize first!");
                return;
            }
            
            try
            {
                // 检查更新
                UpdateStatus("Checking for updates...");
                var checkResult = await LWAssets.Version.CheckUpdateAsync();
                
                if (checkResult.Status == UpdateStatus.NoUpdate)
                {
                    UpdateStatus("No updates available.");
                    return;
                }
                
                UpdateStatus($"Update available: {checkResult.RemoteVersion}, Size: {FileUtility.FormatFileSize(checkResult.DownloadSize)}");
                
                // 开始下载
                var progress = new Progress<DownloadProgress>(p =>
                {
                    _progressSlider.value = p.Progress;
                    UpdateStatus($"Downloading: {p.CompletedCount}/{p.TotalCount} - {FileUtility.FormatFileSize((long)p.Speed)}/s");
                });
                
                await LWAssets.DownloadAsync(null, progress);
                
                _progressSlider.value = 1f;
                UpdateStatus("Download completed!");
            }
            catch (Exception ex)
            {
                UpdateStatus($"Download failed: {ex.Message}");
                Debug.LogException(ex);
            }
        }
        
        /// <summary>
        /// 按标签下载示例
        /// </summary>
        public async UniTask DownloadByTagAsync(params string[] tags)
        {
            if (!LWAssets.IsInitialized)
            {
                await LWAssets.InitializeAsync();
            }
            
            // 获取下载大小
            var downloadSize = await LWAssets.GetDownloadSizeAsync(tags);
            Debug.Log($"Download size for tags [{string.Join(",", tags)}]: {FileUtility.FormatFileSize(downloadSize)}");
            
            // 下载
            await LWAssets.DownloadAsync(tags);
        }
        
        /// <summary>
        /// 清理缓存
        /// </summary>
        private void ClearCache()
        {
            if (!LWAssets.IsInitialized)
            {
                UpdateStatus("Please initialize first!");
                return;
            }
            
            LWAssets.Cache.ClearAll();
            UpdateStatus("Cache cleared!");
        }
        
        /// <summary>
        /// 批量加载示例
        /// </summary>
        public async UniTask BatchLoadAsync()
        {
            if (!LWAssets.IsInitialized)
            {
                await LWAssets.InitializeAsync();
            }
            
            var assetPaths = new[]
            {
                "Assets/Prefabs/Item1.prefab",
                "Assets/Prefabs/Item2.prefab",
                "Assets/Prefabs/Item3.prefab"
            };
            
            var progress = new Progress<float>(p =>
            {
                Debug.Log($"Batch load progress: {p * 100:F1}%");
            });
            
            var assets = await LWAssets.LoadAssetsAsync<GameObject>(assetPaths, progress);
            
            foreach (var asset in assets)
            {
                Debug.Log($"Loaded: {asset?.name}");
            }
        }
        
        /// <summary>
        /// 预加载示例
        /// </summary>
        public void SetupPreload()
        {
            if (!LWAssets.IsInitialized) return;
            
            // 手动请求预加载
            LWAssets.Preloader.RequestPreload("Assets/Prefabs/UI/MainMenu.prefab", PreloadPriority.High);
            LWAssets.Preloader.RequestPreload("Assets/Prefabs/UI/SettingsPanel.prefab", PreloadPriority.Normal);
            
            // 批量预加载
            var preloadList = new[]
            {
                "Assets/Prefabs/Characters/Player.prefab",
                "Assets/Prefabs/Characters/NPC1.prefab",
                "Assets/Prefabs/Effects/Explosion.prefab"
            };
            LWAssets.Preloader.RequestPreload(preloadList, PreloadPriority.Low);
            
            // 使用智能预测
            LWAssets.Preloader.RecordAccess("Assets/Scenes/Level1.unity");
            var predicted = LWAssets.Preloader.GetPredictedAssets("Assets/Scenes/Level1.unity");
            LWAssets.Preloader.RequestPreload(predicted);
        }
        
        /// <summary>
        /// 内存管理示例
        /// </summary>
        public async UniTask MemoryManagementAsync()
        {
            // 获取内存统计
            var stats = LWAssets.Preloader.GetType()
                .GetField("_memoryMonitor", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
                ?.GetValue(LWAssets.Preloader) as MemoryMonitor;
            
            if (stats != null)
            {
                var memStats = stats.GetStatistics();
                Debug.Log($"Memory: {memStats.GetFormattedAllocatedMemory()} / State: {memStats.State}");
            }
            
            // 手动卸载未使用资源
            await LWAssets.UnloadUnusedAssetsAsync();
            
            // 强制卸载所有
            // LWAssets.ForceUnloadAll();
        }
        
        private void UpdateStatus(string message)
        {
            if (_statusText != null)
            {
                _statusText.text = message;
            }
            Debug.Log($"[LWAssetsDemo] {message}");
        }
        
        private void OnDestroy()
        {
            // 清理
            LWAssets.Destroy();
        }
    }
    
    /// <summary>
    /// 高级用法示例 - 游戏启动流程
    /// </summary>
    public class GameLauncher : MonoBehaviour
    {
        public async UniTaskVoid StartGame()
        {
            // 1. 初始化资源系统
            await LWAssets.InitializeAsync();
            
            // 2. 检查更新
            var updateResult = await LWAssets.Version.CheckUpdateAsync();
            
            if (updateResult.Status == UpdateStatus.ForceUpdate)
            {
                // 强制更新，提示用户
                ShowUpdateDialog(updateResult);
                return;
            }
            else if (updateResult.Status == UpdateStatus.OptionalUpdate)
            {
                // 可选更新，询问用户
                if (await ShowOptionalUpdateDialog(updateResult))
                {
                    await DownloadUpdates();
                }
            }
            
            // 3. 下载核心资源
            var coreSize = await LWAssets.GetDownloadSizeAsync(new[] { "core", "ui" });
            if (coreSize > 0)
            {
                await LWAssets.DownloadAsync(new[] { "core", "ui" });
            }
            
            // 4. 加载启动场景
            await LWAssets.LoadSceneAsync("Assets/Scenes/MainMenu.unity");
            
            // 5. 后台下载其他资源
            DownloadBackgroundAsync().Forget();
        }
        
        private async UniTaskVoid DownloadBackgroundAsync()
        {
            // 低优先级后台下载
            await LWAssets.DownloadAsync(new[] { "levels", "characters", "effects" });
        }
        
        private void ShowUpdateDialog(UpdateCheckResult result)
        {
            Debug.Log($"Force update required: {result.LocalVersion} -> {result.RemoteVersion}");
        }
        
        private async UniTask<bool> ShowOptionalUpdateDialog(UpdateCheckResult result)
        {
            Debug.Log($"Optional update available: {result.LocalVersion} -> {result.RemoteVersion}");
            return true; // 模拟用户确认
        }
        
        private async UniTask DownloadUpdates()
        {
            await LWAssets.DownloadAsync();
        }
    }
}
24. Assembly Definition
JSON

// Runtime/LWAssets.Runtime.asmdef
{
    "name": "LWAssets.Runtime",
    "rootNamespace": "LWAssets",
    "references": [
        "UniTask"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
JSON

// Editor/LWAssets.Editor.asmdef
{
    "name": "LWAssets.Editor",
    "rootNamespace": "LWAssets.Editor",
    "references": [
        "LWAssets.Runtime",
        "UniTask"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
使用说明
1. 安装
确保项目已安装 UniTask：通过 Package Manager 安装 com.cysharp.unitask
将 LWAssets 文件夹复制到 Assets/ 目录下
创建配置文件：LWAssets > Dashboard > Create New
2. 配置
运行时配置 (LWAssetsConfig)：

设置运行模式（编辑器模拟/离线/联机/WebGL）
配置远程服务器URL
设置缓存和下载参数
构建配置 (LWAssetsBuildConfig)：

配置分包规则
设置Shader收集
配置标签规则
3. 基本使用
csharp

// 初始化
await LWAssets.InitializeAsync();

// 加载资源
var prefab = await LWAssets.LoadAssetAsync<GameObject>("Assets/Prefabs/Player.prefab");

// 加载场景
var sceneHandle = await LWAssets.LoadSceneAsync("Assets/Scenes/Game.unity");

// 加载原始文件
var configJson = await LWAssets.LoadRawFileTextAsync("Assets/Config/settings.json");

// 下载资源
await LWAssets.DownloadAsync(new[] { "core", "level1" }, progress);

// 释放资源
LWAssets.Release(prefab);
await LWAssets.UnloadUnusedAssetsAsync();
这套系统实现了您要求的所有功能，包括多种运行模式、灵活的分包策略、智能下载管理、缓存管理、预加载系统、完整的同步/异步API，以及强大的编辑器工具支持。






继续生成

claude-opus-4-5-20251101
11. 下载管理器（续）
csharp

// Runtime/Download/DownloadManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

namespace LWAssets
{
    /// <summary>
    /// 下载进度
    /// </summary>
    public struct DownloadProgress
    {
        public int TotalCount;
        public int CompletedCount;
        public long TotalBytes;
        public long DownloadedBytes;
        public float Progress => TotalBytes > 0 ? (float)DownloadedBytes / TotalBytes : 0;
        public string CurrentFile;
        public float Speed; // bytes per second
    }
    
    /// <summary>
    /// 下载任务
    /// </summary>
    public class DownloadTask
    {
        public string Url;
        public string SavePath;
        public long ExpectedSize;
        public string ExpectedHash;
        public int RetryCount;
        public long DownloadedBytes;
        public DownloadTaskStatus Status;
        public Exception Error;
        
        public event Action<DownloadTask> OnProgress;
        public event Action<DownloadTask> OnCompleted;
        public event Action<DownloadTask> OnFailed;
        
        internal void NotifyProgress() => OnProgress?.Invoke(this);
        internal void NotifyCompleted() => OnCompleted?.Invoke(this);
        internal void NotifyFailed() => OnFailed?.Invoke(this);
    }
    
    public enum DownloadTaskStatus
    {
        Pending,
        Downloading,
        Completed,
        Failed,
        Cancelled
    }
    
    /// <summary>
    /// 下载管理器
    /// </summary>
    public class DownloadManager : IDisposable
    {
        private readonly LWAssetsConfig _config;
        private readonly Queue<DownloadTask> _pendingQueue = new Queue<DownloadTask>();
        private readonly List<DownloadTask> _activeTasks = new List<DownloadTask>();
        private readonly Dictionary<string, DownloadTask> _taskMap = new Dictionary<string, DownloadTask>();
        
        private CancellationTokenSource _cts;
        private bool _isRunning;
        private long _totalDownloadedBytes;
        private DateTime _lastSpeedCalculateTime;
        private long _lastDownloadedBytes;
        private float _currentSpeed;
        
        private readonly object _lockObj = new object();
        
        public int PendingCount => _pendingQueue.Count;
        public int ActiveCount => _activeTasks.Count;
        public bool IsRunning => _isRunning;
        public float CurrentSpeed => _currentSpeed;
        
        public event Action<DownloadTask> OnTaskCompleted;
        public event Action<DownloadTask> OnTaskFailed;
        public event Action OnAllCompleted;
        
        public DownloadManager(LWAssetsConfig config)
        {
            _config = config;
            _cts = new CancellationTokenSource();
        }
        
        #region 公共方法
        
        /// <summary>
        /// 下载Bundle列表
        /// </summary>
        public async UniTask DownloadAsync(IEnumerable<BundleInfo> bundles, 
            IProgress<DownloadProgress> progress = null,
            CancellationToken cancellationToken = default)
        {
            var tasks = new List<DownloadTask>();
            long totalSize = 0;
            
            foreach (var bundle in bundles)
            {
                var url = _config.GetRemoteURL() + bundle.GetFileName();
                var savePath = Path.Combine(_config.GetPersistentDataPath(), bundle.GetFileName());
                
                // 检查是否已下载
                if (File.Exists(savePath))
                {
                    var fileInfo = new FileInfo(savePath);
                    if (fileInfo.Length == bundle.Size)
                    {
                        // 验证哈希
                        if (ValidateFileHash(savePath, bundle.Hash))
                        {
                            continue; // 已存在且有效
                        }
                    }
                }
                
                var task = new DownloadTask
                {
                    Url = url,
                    SavePath = savePath,
                    ExpectedSize = bundle.Size,
                    ExpectedHash = bundle.Hash,
                    Status = DownloadTaskStatus.Pending
                };
                
                tasks.Add(task);
                totalSize += bundle.Size;
            }
            
            if (tasks.Count == 0)
            {
                progress?.Report(new DownloadProgress
                {
                    TotalCount = 0,
                    CompletedCount = 0,
                    TotalBytes = 0,
                    DownloadedBytes = 0
                });
                return;
            }
            
            // 添加到队列
            foreach (var task in tasks)
            {
                EnqueueTask(task);
            }
            
            // 启动下载
            StartDownloading();
            
            // 等待所有任务完成
            var downloadProgress = new DownloadProgress
            {
                TotalCount = tasks.Count,
                TotalBytes = totalSize
            };
            
            using (var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, _cts.Token))
            {
                while (true)
                {
                    linkedCts.Token.ThrowIfCancellationRequested();
                    
                    // 计算进度
                    int completedCount = 0;
                    long downloadedBytes = 0;
                    string currentFile = null;
                    
                    foreach (var task in tasks)
                    {
                        if (task.Status == DownloadTaskStatus.Completed)
                        {
                            completedCount++;
                            downloadedBytes += task.ExpectedSize;
                        }
                        else if (task.Status == DownloadTaskStatus.Downloading)
                        {
                            currentFile = Path.GetFileName(task.SavePath);
                            downloadedBytes += task.DownloadedBytes;
                        }
                        else if (task.Status == DownloadTaskStatus.Failed)
                        {
                            throw task.Error ?? new Exception($"Download failed: {task.Url}");
                        }
                    }
                    
                    downloadProgress.CompletedCount = completedCount;
                    downloadProgress.DownloadedBytes = downloadedBytes;
                    downloadProgress.CurrentFile = currentFile;
                    downloadProgress.Speed = _currentSpeed;
                    
                    progress?.Report(downloadProgress);
                    
                    if (completedCount >= tasks.Count)
                    {
                        break;
                    }
                    
                    await UniTask.Delay(100, cancellationToken: linkedCts.Token);
                }
            }
        }
        
        /// <summary>
        /// 添加下载任务
        /// </summary>
        public void EnqueueTask(DownloadTask task)
        {
            lock (_lockObj)
            {
                if (_taskMap.ContainsKey(task.Url))
                {
                    return; // 避免重复
                }
                
                _taskMap[task.Url] = task;
                _pendingQueue.Enqueue(task);
            }
        }
        
        /// <summary>
        /// 开始下载
        /// </summary>
        public void StartDownloading()
        {
            if (_isRunning) return;
            
            _isRunning = true;
            _lastSpeedCalculateTime = DateTime.Now;
            _lastDownloadedBytes = 0;
            
            ProcessQueue().Forget();
        }
        
        /// <summary>
        /// 暂停下载
        /// </summary>
        public void Pause()
        {
            _isRunning = false;
        }
        
        /// <summary>
        /// 取消所有下载
        /// </summary>
        public void CancelAll()
        {
            _cts.Cancel();
            _cts = new CancellationTokenSource();
            
            lock (_lockObj)
            {
                _pendingQueue.Clear();
                _activeTasks.Clear();
                _taskMap.Clear();
            }
            
            _isRunning = false;
        }
        
        #endregion
        
        #region 内部方法
        
        /// <summary>
        /// 处理下载队列
        /// </summary>
        private async UniTaskVoid ProcessQueue()
        {
            while (_isRunning)
            {
                // 计算速度
                CalculateSpeed();
                
                // 填充活动任务
                while (_activeTasks.Count < _config.MaxConcurrentDownloads)
                {
                    DownloadTask task;
                    lock (_lockObj)
                    {
                        if (_pendingQueue.Count == 0) break;
                        task = _pendingQueue.Dequeue();
                        _activeTasks.Add(task);
                    }
                    
                    // 启动下载
                    DownloadTaskAsync(task, _cts.Token).Forget();
                }
                
                // 检查是否全部完成
                lock (_lockObj)
                {
                    if (_pendingQueue.Count == 0 && _activeTasks.Count == 0)
                    {
                        _isRunning = false;
                        OnAllCompleted?.Invoke();
                        break;
                    }
                }
                
                await UniTask.Delay(50);
            }
        }
        
        /// <summary>
        /// 执行单个下载任务
        /// </summary>
        private async UniTaskVoid DownloadTaskAsync(DownloadTask task, CancellationToken cancellationToken)
        {
            task.Status = DownloadTaskStatus.Downloading;
            
            try
            {
                // 确保目录存在
                var directory = Path.GetDirectoryName(task.SavePath);
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }
                
                // 检查断点续传
                long startPosition = 0;
                string tempPath = task.SavePath + ".tmp";
                
                if (_config.EnableBreakpointResume && File.Exists(tempPath))
                {
                    var fileInfo = new FileInfo(tempPath);
                    startPosition = fileInfo.Length;
                    task.DownloadedBytes = startPosition;
                }
                
                // 创建请求
                using (var request = new UnityWebRequest(task.Url, UnityWebRequest.kHttpVerbGET))
                {
                    // 设置断点续传
                    if (startPosition > 0)
                    {
                        request.SetRequestHeader("Range", $"bytes={startPosition}-");
                    }
                    
                    // 使用自定义下载处理器
                    var downloadHandler = new DownloadHandlerFileWithProgress(tempPath, startPosition, task);
                    request.downloadHandler = downloadHandler;
                    request.timeout = _config.DownloadTimeout;
                    
                    var operation = request.SendWebRequest();
                    
                    while (!operation.isDone)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        
                        task.DownloadedBytes = startPosition + (long)(request.downloadedBytes);
                        task.NotifyProgress();
                        
                        Interlocked.Add(ref _totalDownloadedBytes, (long)request.downloadedBytes);
                        
                        await UniTask.Yield(cancellationToken);
                    }
                    
                    if (request.result != UnityWebRequest.Result.Success)
                    {
                        throw new Exception($"Download failed: {request.error}");
                    }
                }
                
                // 验证文件
                if (!string.IsNullOrEmpty(task.ExpectedHash))
                {
                    if (!ValidateFileHash(tempPath, task.ExpectedHash))
                    {
                        File.Delete(tempPath);
                        throw new Exception("File hash mismatch");
                    }
                }
                
                // 重命名临时文件
                if (File.Exists(task.SavePath))
                {
                    File.Delete(task.SavePath);
                }
                File.Move(tempPath, task.SavePath);
                
                task.Status = DownloadTaskStatus.Completed;
                task.NotifyCompleted();
                OnTaskCompleted?.Invoke(task);
            }
            catch (OperationCanceledException)
            {
                task.Status = DownloadTaskStatus.Cancelled;
            }
            catch (Exception ex)
            {
                task.Error = ex;
                task.RetryCount++;
                
                if (task.RetryCount < _config.MaxRetryCount)
                {
                    // 重试
                    Debug.LogWarning($"[LWAssets] Download retry {task.RetryCount}/{_config.MaxRetryCount}: {task.Url}");
                    await UniTask.Delay(TimeSpan.FromSeconds(_config.RetryDelay), cancellationToken: cancellationToken);
                    
                    lock (_lockObj)
                    {
                        _activeTasks.Remove(task);
                        _pendingQueue.Enqueue(task);
                    }
                    return;
                }
                
                task.Status = DownloadTaskStatus.Failed;
                task.NotifyFailed();
                OnTaskFailed?.Invoke(task);
                Debug.LogError($"[LWAssets] Download failed: {task.Url}, Error: {ex.Message}");
            }
            finally
            {
                lock (_lockObj)
                {
                    _activeTasks.Remove(task);
                }
            }
        }
        
        /// <summary>
        /// 计算下载速度
        /// </summary>
        private void CalculateSpeed()
        {
            var now = DateTime.Now;
            var elapsed = (now - _lastSpeedCalculateTime).TotalSeconds;
            
            if (elapsed >= 1.0)
            {
                var bytesDownloaded = _totalDownloadedBytes - _lastDownloadedBytes;
                _currentSpeed = (float)(bytesDownloaded / elapsed);
                
                _lastSpeedCalculateTime = now;
                _lastDownloadedBytes = _totalDownloadedBytes;
            }
        }
        
        /// <summary>
        /// 验证文件哈希
        /// </summary>
        private bool ValidateFileHash(string filePath, string expectedHash)
        {
            if (string.IsNullOrEmpty(expectedHash)) return true;
            
            var actualHash = HashUtility.ComputeFileMD5(filePath);
            return string.Equals(actualHash, expectedHash, StringComparison.OrdinalIgnoreCase);
        }
        
        #endregion
        
        public void Dispose()
        {
            CancelAll();
            _cts?.Dispose();
        }
    }
    
    /// <summary>
    /// 支持进度和断点续传的下载处理器
    /// </summary>
    public class DownloadHandlerFileWithProgress : DownloadHandlerScript
    {
        private readonly FileStream _fileStream;
        private readonly DownloadTask _task;
        private readonly long _startPosition;
        
        public DownloadHandlerFileWithProgress(string path, long startPosition, DownloadTask task) 
            : base(new byte[1024 * 1024]) // 1MB buffer
        {
            _startPosition = startPosition;
            _task = task;
            
            _fileStream = new FileStream(path, 
                startPosition > 0 ? FileMode.Append : FileMode.Create, 
                FileAccess.Write);
        }
        
        protected override bool ReceiveData(byte[] data, int dataLength)
        {
            if (data == null || dataLength == 0) return false;
            
            _fileStream.Write(data, 0, dataLength);
            return true;
        }
        
        protected override void CompleteContent()
        {
            _fileStream?.Flush();
            _fileStream?.Close();
        }
        
        public override void Dispose()
        {
            _fileStream?.Dispose();
            base.Dispose();
        }
    }
}
12. 缓存管理器
csharp

// Runtime/Cache/CacheManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace LWAssets
{
    /// <summary>
    /// 缓存条目信息
    /// </summary>
    [Serializable]
    public class CacheEntry
    {
        public string FileName;
        public string Hash;
        public long Size;
        public DateTime LastAccessTime;
        public DateTime CreateTime;
        public int AccessCount;
    }
    
    /// <summary>
    /// 缓存索引
    /// </summary>
    [Serializable]
    public class CacheIndex
    {
        public List<CacheEntry> Entries = new List<CacheEntry>();
        public long TotalSize;
        public DateTime LastUpdateTime;
    }
    
    /// <summary>
    /// 缓存管理器
    /// </summary>
    public class CacheManager : IDisposable
    {
        private readonly LWAssetsConfig _config;
        private CacheIndex _cacheIndex;
        private readonly Dictionary<string, CacheEntry> _entryDict = new Dictionary<string, CacheEntry>();
        private readonly string _cachePath;
        private readonly string _indexPath;
        private bool _isDirty;
        
        private readonly object _lockObj = new object();
        
        public long TotalCacheSize => _cacheIndex?.TotalSize ?? 0;
        public int EntryCount => _cacheIndex?.Entries.Count ?? 0;
        public long MaxCacheSize => _config.MaxCacheSize;
        public float UsageRatio => MaxCacheSize > 0 ? (float)TotalCacheSize / MaxCacheSize : 0;
        
        public CacheManager(LWAssetsConfig config)
        {
            _config = config;
            _cachePath = config.GetPersistentDataPath();
            _indexPath = Path.Combine(_cachePath, "cache_index.json");
            
            LoadIndex();
        }
        
        #region 索引管理
        
        /// <summary>
        /// 加载缓存索引
        /// </summary>
        private void LoadIndex()
        {
            try
            {
                if (File.Exists(_indexPath))
                {
                    var json = File.ReadAllText(_indexPath);
                    _cacheIndex = JsonUtility.FromJson<CacheIndex>(json);
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[LWAssets] Failed to load cache index: {ex.Message}");
            }
            
            if (_cacheIndex == null)
            {
                _cacheIndex = new CacheIndex();
            }
            
            // 构建字典
            _entryDict.Clear();
            foreach (var entry in _cacheIndex.Entries)
            {
                _entryDict[entry.FileName] = entry;
            }
            
            // 验证缓存文件
            ValidateCache();
        }
        
        /// <summary>
        /// 保存缓存索引
        /// </summary>
        public void SaveIndex()
        {
            if (!_isDirty) return;
            
            try
            {
                if (!Directory.Exists(_cachePath))
                {
                    Directory.CreateDirectory(_cachePath);
                }
                
                _cacheIndex.LastUpdateTime = DateTime.Now;
                var json = JsonUtility.ToJson(_cacheIndex, true);
                File.WriteAllText(_indexPath, json);
                _isDirty = false;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[LWAssets] Failed to save cache index: {ex.Message}");
            }
        }
        
        /// <summary>
        /// 验证缓存
        /// </summary>
        private void ValidateCache()
        {
            var toRemove = new List<string>();
            long totalSize = 0;
            
            foreach (var entry in _cacheIndex.Entries)
            {
                var filePath = Path.Combine(_cachePath, entry.FileName);
                if (!File.Exists(filePath))
                {
                    toRemove.Add(entry.FileName);
                    continue;
                }
                
                var fileInfo = new FileInfo(filePath);
                if (fileInfo.Length != entry.Size)
                {
                    toRemove.Add(entry.FileName);
                    File.Delete(filePath);
                    continue;
                }
                
                totalSize += entry.Size;
            }
            
            // 移除无效条目
            foreach (var fileName in toRemove)
            {
                RemoveEntry(fileName);
            }
            
            _cacheIndex.TotalSize = totalSize;
            
            if (toRemove.Count > 0)
            {
                _isDirty = true;
                SaveIndex();
            }
        }
        
        #endregion
        
        #region 缓存操作
        
        /// <summary>
        /// 添加缓存条目
        /// </summary>
        public void AddEntry(BundleInfo bundleInfo)
        {
            lock (_lockObj)
            {
                var fileName = bundleInfo.GetFileName();
                
                if (_entryDict.ContainsKey(fileName))
                {
                    // 更新访问时间
                    var entry = _entryDict[fileName];
                    entry.LastAccessTime = DateTime.Now;
                    entry.AccessCount++;
                }
                else
                {
                    var entry = new CacheEntry
                    {
                        FileName = fileName,
                        Hash = bundleInfo.Hash,
                        Size = bundleInfo.Size,
                        CreateTime = DateTime.Now,
                        LastAccessTime = DateTime.Now,
                        AccessCount = 1
                    };
                    
                    _cacheIndex.Entries.Add(entry);
                    _entryDict[fileName] = entry;
                    _cacheIndex.TotalSize += entry.Size;
                }
                
                _isDirty = true;
                
                // 检查是否需要清理
                if (_config.EnableAutoCleanup && UsageRatio >= _config.CleanupThreshold)
                {
                    CleanupAsync().Forget();
                }
            }
        }
        
        /// <summary>
        /// 移除缓存条目
        /// </summary>
        public void RemoveEntry(string fileName)
        {
            lock (_lockObj)
            {
                if (_entryDict.TryGetValue(fileName, out var entry))
                {
                    _cacheIndex.Entries.Remove(entry);
                    _entryDict.Remove(fileName);
                    _cacheIndex.TotalSize -= entry.Size;
                    _isDirty = true;
                }
            }
        }
        
        /// <summary>
        /// 检查Bundle是否已缓存且有效
        /// </summary>
        public bool ValidateBundle(BundleInfo bundleInfo)
        {
            lock (_lockObj)
            {
                var fileName = bundleInfo.GetFileName();
                
                if (!_entryDict.TryGetValue(fileName, out var entry))
                {
                    return false;
                }
                
                // 验证哈希
                if (entry.Hash != bundleInfo.Hash)
                {
                    return false;
                }
                
                // 验证文件存在
                var filePath = Path.Combine(_cachePath, fileName);
                if (!File.Exists(filePath))
                {
                    RemoveEntry(fileName);
                    return false;
                }
                
                // 更新访问时间
                entry.LastAccessTime = DateTime.Now;
                entry.AccessCount++;
                _isDirty = true;
                
                return true;
            }
        }
        
        /// <summary>
        /// 获取缓存文件路径
        /// </summary>
        public string GetCachePath(BundleInfo bundleInfo)
        {
            return Path.Combine(_cachePath, bundleInfo.GetFileName());
        }
        
        /// <summary>
        /// 检查缓存是否存在
        /// </summary>
        public bool HasCache(string fileName)
        {
            lock (_lockObj)
            {
                return _entryDict.ContainsKey(fileName);
            }
        }
        
        #endregion
        
        #region 缓存清理
        
        /// <summary>
        /// 清理缓存
        /// </summary>
        public async UniTask CleanupAsync(long targetFreeSpace = 0)
        {
            if (targetFreeSpace <= 0)
            {
                targetFreeSpace = (long)(_config.MaxCacheSize * (1 - _config.CleanupThreshold * 0.8f));
            }
            
            Debug.Log($"[LWAssets] Starting cache cleanup, target free space: {targetFreeSpace / 1024 / 1024}MB");
            
            var freedSpace = 0L;
            var toRemove = new List<CacheEntry>();
            
            lock (_lockObj)
            {
                // 按LRU策略排序
                var sortedEntries = _cacheIndex.Entries
                    .OrderBy(e => e.LastAccessTime)
                    .ThenBy(e => e.AccessCount)
                    .ToList();
                
                foreach (var entry in sortedEntries)
                {
                    if (freedSpace >= targetFreeSpace) break;
                    
                    // 检查是否过期
                    var daysSinceAccess = (DateTime.Now - entry.LastAccessTime).TotalDays;
                    if (daysSinceAccess > _config.CacheExpirationDays || freedSpace < targetFreeSpace)
                    {
                        toRemove.Add(entry);
                        freedSpace += entry.Size;
                    }
                }
            }
            
            // 删除文件
            foreach (var entry in toRemove)
            {
                try
                {
                    var filePath = Path.Combine(_cachePath, entry.FileName);
                    if (File.Exists(filePath))
                    {
                        File.Delete(filePath);
                    }
                    RemoveEntry(entry.FileName);
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[LWAssets] Failed to delete cache file: {entry.FileName}, Error: {ex.Message}");
                }
                
                await UniTask.Yield();
            }
            
            SaveIndex();
            Debug.Log($"[LWAssets] Cache cleanup completed, freed {freedSpace / 1024 / 1024}MB");
        }
        
        /// <summary>
        /// 清除所有缓存
        /// </summary>
        public void ClearAll()
        {
            lock (_lockObj)
            {
                // 删除所有缓存文件
                if (Directory.Exists(_cachePath))
                {
                    var files = Directory.GetFiles(_cachePath);
                    foreach (var file in files)
                    {
                        try
                        {
                            File.Delete(file);
                        }
                        catch (Exception ex)
                        {
                            Debug.LogWarning($"[LWAssets] Failed to delete file: {file}, Error: {ex.Message}");
                        }
                    }
                }
                
                _cacheIndex.Entries.Clear();
                _entryDict.Clear();
                _cacheIndex.TotalSize = 0;
                _isDirty = true;
                SaveIndex();
            }
            
            Debug.Log("[LWAssets] All cache cleared");
        }
        
        /// <summary>
        /// 清除指定标签的缓存
        /// </summary>
        public void ClearByTag(string tag, BundleManifest manifest)
        {
            var bundles = manifest.GetBundlesByTag(tag);
            foreach (var bundle in bundles)
            {
                var fileName = bundle.GetFileName();
                var filePath = Path.Combine(_cachePath, fileName);
                
                if (File.Exists(filePath))
                {
                    try
                    {
                        File.Delete(filePath);
                    }
                    catch { }
                }
                
                RemoveEntry(fileName);
            }
            
            SaveIndex();
        }
        
        #endregion
        
        /// <summary>
        /// 获取缓存统计信息
        /// </summary>
        public CacheStatistics GetStatistics()
        {
            lock (_lockObj)
            {
                return new CacheStatistics
                {
                    TotalSize = _cacheIndex.TotalSize,
                    EntryCount = _cacheIndex.Entries.Count,
                    MaxSize = _config.MaxCacheSize,
                    OldestAccessTime = _cacheIndex.Entries.Count > 0 
                        ? _cacheIndex.Entries.Min(e => e.LastAccessTime) 
                        : DateTime.Now,
                    NewestAccessTime = _cacheIndex.Entries.Count > 0 
                        ? _cacheIndex.Entries.Max(e => e.LastAccessTime) 
                        : DateTime.Now
                };
            }
        }
        
        public void Dispose()
        {
            SaveIndex();
        }
    }
    
    /// <summary>
    /// 缓存统计信息
    /// </summary>
    public struct CacheStatistics
    {
        public long TotalSize;
        public int EntryCount;
        public long MaxSize;
        public DateTime OldestAccessTime;
        public DateTime NewestAccessTime;
        public float UsageRatio => MaxSize > 0 ? (float)TotalSize / MaxSize : 0;
    }
}
13. 版本管理器
csharp

// Runtime/Cache/VersionManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

namespace LWAssets
{
    /// <summary>
    /// 版本信息
    /// </summary>
    [Serializable]
    public class VersionInfo
    {
        public string Version;
        public string ManifestHash;
        public long ManifestSize;
        public string BuildTime;
        public string MinAppVersion;
        public bool ForceUpdate;
    }
    
    /// <summary>
    /// 版本管理器
    /// </summary>
    public class VersionManager
    {
        private readonly LWAssetsConfig _config;
        private readonly CacheManager _cacheManager;
        
        private VersionInfo _localVersion;
        private VersionInfo _remoteVersion;
        private BundleManifest _localManifest;
        private BundleManifest _remoteManifest;
        
        public VersionInfo LocalVersion => _localVersion;
        public VersionInfo RemoteVersion => _remoteVersion;
        public bool HasNewVersion => _remoteVersion != null && _localVersion?.Version != _remoteVersion.Version;
        
        public VersionManager(LWAssetsConfig config, CacheManager cacheManager)
        {
            _config = config;
            _cacheManager = cacheManager;
        }
        
        #region 初始化
        
        /// <summary>
        /// 初始化版本信息
        /// </summary>
        public async UniTask InitializeAsync()
        {
            // 加载本地版本信息
            _localVersion = await LoadLocalVersionAsync();
            
            // 如果是在线模式，检查远程版本
            if (_config.PlayMode == PlayMode.Online)
            {
                try
                {
                    _remoteVersion = await LoadRemoteVersionAsync();
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[LWAssets] Failed to load remote version: {ex.Message}");
                }
            }
            
            Debug.Log($"[LWAssets] Version initialized - Local: {_localVersion?.Version}, Remote: {_remoteVersion?.Version}");
        }
        
        /// <summary>
        /// 加载本地版本信息
        /// </summary>
        private async UniTask<VersionInfo> LoadLocalVersionAsync()
        {
            // 优先从缓存目录加载
            var cachePath = Path.Combine(_config.GetPersistentDataPath(), _config.VersionFileName);
            if (File.Exists(cachePath))
            {
                try
                {
                    var json = await File.ReadAllTextAsync(cachePath);
                    return JsonUtility.FromJson<VersionInfo>(json);
                }
                catch { }
            }
            
            // 其次从StreamingAssets加载
            var streamingPath = Path.Combine(_config.GetStreamingAssetsPath(), _config.VersionFileName);
            
            #if UNITY_ANDROID && !UNITY_EDITOR
            // Android需要使用UnityWebRequest
            using (var request = UnityWebRequest.Get(streamingPath))
            {
                await request.SendWebRequest();
                if (request.result == UnityWebRequest.Result.Success)
                {
                    return JsonUtility.FromJson<VersionInfo>(request.downloadHandler.text);
                }
            }
            #else
            if (File.Exists(streamingPath))
            {
                var json = await File.ReadAllTextAsync(streamingPath);
                return JsonUtility.FromJson<VersionInfo>(json);
            }
            #endif
            
            return null;
        }
        
        /// <summary>
        /// 加载远程版本信息
        /// </summary>
        private async UniTask<VersionInfo> LoadRemoteVersionAsync()
        {
            var url = _config.GetRemoteURL() + _config.VersionFileName;
            
            using (var request = UnityWebRequest.Get(url))
            {
                request.timeout = 10;
                await request.SendWebRequest();
                
                if (request.result == UnityWebRequest.Result.Success)
                {
                    return JsonUtility.FromJson<VersionInfo>(request.downloadHandler.text);
                }
                else
                {
                    throw new Exception($"Failed to load remote version: {request.error}");
                }
            }
        }
        
        #endregion
        
        #region 清单管理
        
        /// <summary>
        /// 加载清单文件
        /// </summary>
        public async UniTask<BundleManifest> LoadManifestAsync()
        {
            // 检查是否需要更新清单
            if (_config.PlayMode == PlayMode.Online && HasNewVersion)
            {
                try
                {
                    var manifest = await LoadRemoteManifestAsync();
                    if (manifest != null)
                    {
                        // 保存到本地
                        await SaveManifestAsync(manifest);
                        await SaveVersionAsync(_remoteVersion);
                        _localManifest = manifest;
                        _localVersion = _remoteVersion;
                        return manifest;
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[LWAssets] Failed to load remote manifest: {ex.Message}");
                }
            }
            
            // 加载本地清单
            _localManifest = await LoadLocalManifestAsync();
            return _localManifest;
        }
        
        /// <summary>
        /// 加载本地清单
        /// </summary>
        private async UniTask<BundleManifest> LoadLocalManifestAsync()
        {
            // 优先从缓存目录加载
            var cachePath = Path.Combine(_config.GetPersistentDataPath(), _config.ManifestFileName);
            if (File.Exists(cachePath))
            {
                try
                {
                    var json = await File.ReadAllTextAsync(cachePath);
                    return BundleManifest.FromJson(json);
                }
                catch { }
            }
            
            // 其次从StreamingAssets加载
            var streamingPath = Path.Combine(_config.GetStreamingAssetsPath(), _config.ManifestFileName);
            
            #if UNITY_ANDROID && !UNITY_EDITOR
            using (var request = UnityWebRequest.Get(streamingPath))
            {
                await request.SendWebRequest();
                if (request.result == UnityWebRequest.Result.Success)
                {
                    return BundleManifest.FromJson(request.downloadHandler.text);
                }
            }
            #else
            if (File.Exists(streamingPath))
            {
                var json = await File.ReadAllTextAsync(streamingPath);
                return BundleManifest.FromJson(json);
            }
            #endif
            
            return new BundleManifest();
        }
        
        /// <summary>
        /// 加载远程清单
        /// </summary>
        private async UniTask<BundleManifest> LoadRemoteManifestAsync()
        {
            var url = _config.GetRemoteURL() + _config.ManifestFileName;
            
            using (var request = UnityWebRequest.Get(url))
            {
                request.timeout = 30;
                await request.SendWebRequest();
                
                if (request.result == UnityWebRequest.Result.Success)
                {
                    _remoteManifest = BundleManifest.FromJson(request.downloadHandler.text);
                    return _remoteManifest;
                }
                else
                {
                    throw new Exception($"Failed to load remote manifest: {request.error}");
                }
            }
        }
        
        /// <summary>
        /// 保存清单到本地
        /// </summary>
        private async UniTask SaveManifestAsync(BundleManifest manifest)
        {
            var path = Path.Combine(_config.GetPersistentDataPath(), _config.ManifestFileName);
            var directory = Path.GetDirectoryName(path);
            
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }
            
            var json = manifest.ToJson();
            await File.WriteAllTextAsync(path, json);
        }
        
        /// <summary>
        /// 保存版本信息到本地
        /// </summary>
        private async UniTask SaveVersionAsync(VersionInfo version)
        {
            var path = Path.Combine(_config.GetPersistentDataPath(), _config.VersionFileName);
            var json = JsonUtility.ToJson(version);
            await File.WriteAllTextAsync(path, json);
        }
        
        #endregion
        
        #region 更新检测
        
        /// <summary>
        /// 检查更新
        /// </summary>
        public async UniTask<UpdateCheckResult> CheckUpdateAsync()
        {
            var result = new UpdateCheckResult();
            
            try
            {
                _remoteVersion = await LoadRemoteVersionAsync();
                
                if (_remoteVersion == null)
                {
                    result.Status = UpdateStatus.CheckFailed;
                    result.Error = "Failed to load remote version";
                    return result;
                }
                
                if (_localVersion?.Version == _remoteVersion.Version)
                {
                    result.Status = UpdateStatus.NoUpdate;
                    return result;
                }
                
                // 检查是否强制更新
                if (_remoteVersion.ForceUpdate)
                {
                    result.Status = UpdateStatus.ForceUpdate;
                }
                else
                {
                    result.Status = UpdateStatus.OptionalUpdate;
                }
                
                result.LocalVersion = _localVersion?.Version;
                result.RemoteVersion = _remoteVersion.Version;
                
                // 加载远程清单计算下载大小
                var remoteManifest = await LoadRemoteManifestAsync();
                var downloadBundles = await GetBundlesToDownloadAsync(null, remoteManifest);
                result.DownloadSize = downloadBundles.Sum(b => b.Size);
                result.DownloadCount = downloadBundles.Count;
            }
            catch (Exception ex)
            {
                result.Status = UpdateStatus.CheckFailed;
                result.Error = ex.Message;
            }
            
            return result;
        }
        
        /// <summary>
        /// 获取需要下载的Bundle大小
        /// </summary>
        public async UniTask<long> GetDownloadSizeAsync(string[] tags = null)
        {
            var bundles = await GetBundlesToDownloadAsync(tags);
            return bundles.Sum(b => b.Size);
        }
        
        /// <summary>
        /// 获取需要下载的Bundle列表
        /// </summary>
        public async UniTask<List<BundleInfo>> GetBundlesToDownloadAsync(string[] tags = null, 
            BundleManifest manifest = null)
        {
            if (manifest == null)
            {
                manifest = _remoteManifest ?? _localManifest;
            }
            
            if (manifest == null)
            {
                return new List<BundleInfo>();
            }
            
            var bundlesToDownload = new List<BundleInfo>();
            var bundlesToCheck = tags != null && tags.Length > 0
                ? tags.SelectMany(t => manifest.GetBundlesByTag(t)).Distinct().ToList()
                : manifest.Bundles;
            
            foreach (var bundle in bundlesToCheck)
            {
                // 检查缓存
                if (_cacheManager.ValidateBundle(bundle))
                {
                    continue;
                }
                
                // 检查StreamingAssets
                var streamingPath = Path.Combine(_config.GetStreamingAssetsPath(), bundle.GetFileName());
                if (File.Exists(streamingPath))
                {
                    continue;
                }
                
                bundlesToDownload.Add(bundle);
            }
            
            await UniTask.CompletedTask;
            return bundlesToDownload;
        }
        
        #endregion
    }
    
    /// <summary>
    /// 更新状态
    /// </summary>
    public enum UpdateStatus
    {
        NoUpdate,
        OptionalUpdate,
        ForceUpdate,
        CheckFailed
    }
    
    /// <summary>
    /// 更新检查结果
    /// </summary>
    public struct UpdateCheckResult
    {
        public UpdateStatus Status;
        public string LocalVersion;
        public string RemoteVersion;
        public long DownloadSize;
        public int DownloadCount;
        public string Error;
    }
}
14. 预加载管理器
csharp

// Runtime/Preload/PreloadManager.cs
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace LWAssets
{
    /// <summary>
    /// 预加载优先级
    /// </summary>
    public enum PreloadPriority
    {
        Low = 0,
        Normal = 1,
        High = 2,
        Critical = 3
    }
    
    /// <summary>
    /// 预加载请求
    /// </summary>
    public class PreloadRequest
    {
        public string AssetPath;
        public Type AssetType;
        public PreloadPriority Priority;
        public DateTime RequestTime;
        public bool IsCompleted;
        public bool IsCancelled;
        
        internal CancellationTokenSource CTS;
    }
    
    /// <summary>
    /// 预加载管理器
    /// </summary>
    public class PreloadManager : IDisposable
    {
        private readonly LWAssetsConfig _config;
        private readonly MemoryMonitor _memoryMonitor;
        private readonly PreloadPredictor _predictor;
        
        private readonly PriorityQueue<PreloadRequest> _pendingQueue;
        private readonly List<PreloadRequest> _activeRequests;
        private readonly Dictionary<string, PreloadRequest> _requestMap;
        private readonly HashSet<string> _preloadedAssets;
        
        private CancellationTokenSource _cts;
        private bool _isRunning;
        private readonly object _lockObj = new object();
        
        public bool IsEnabled => _config.EnablePreload;
        public int PendingCount => _pendingQueue.Count;
        public int ActiveCount => _activeRequests.Count;
        public int PreloadedCount => _preloadedAssets.Count;
        
        public event Action<string> OnAssetPreloaded;
        public event Action<string> OnPreloadFailed;
        
        public PreloadManager(LWAssetsConfig config)
        {
            _config = config;
            _memoryMonitor = new MemoryMonitor(config);
            _predictor = new PreloadPredictor();
            
            _pendingQueue = new PriorityQueue<PreloadRequest>(
                (a, b) => b.Priority.CompareTo(a.Priority)); // 高优先级在前
            _activeRequests = new List<PreloadRequest>();
            _requestMap = new Dictionary<string, PreloadRequest>();
            _preloadedAssets = new HashSet<string>();
            
            _cts = new CancellationTokenSource();
            
            if (_config.EnablePreload)
            {
                StartPreloading();
            }
        }
        
        #region 公共方法
        
        /// <summary>
        /// 请求预加载资源
        /// </summary>
        public void RequestPreload(string assetPath, PreloadPriority priority = PreloadPriority.Normal)
        {
            if (!_config.EnablePreload) return;
            if (string.IsNullOrEmpty(assetPath)) return;
            
            lock (_lockObj)
            {
                // 检查是否已预加载
                if (_preloadedAssets.Contains(assetPath)) return;
                
                // 检查是否已在队列中
                if (_requestMap.ContainsKey(assetPath)) return;
                
                var request = new PreloadRequest
                {
                    AssetPath = assetPath,
                    Priority = priority,
                    RequestTime = DateTime.Now,
                    CTS = new CancellationTokenSource()
                };
                
                _requestMap[assetPath] = request;
                _pendingQueue.Enqueue(request);
            }
        }
        
        /// <summary>
        /// 批量请求预加载
        /// </summary>
        public void RequestPreload(IEnumerable<string> assetPaths, PreloadPriority priority = PreloadPriority.Normal)
        {
            foreach (var path in assetPaths)
            {
                RequestPreload(path, priority);
            }
        }
        
        /// <summary>
        /// 取消预加载请求
        /// </summary>
        public void CancelPreload(string assetPath)
        {
            lock (_lockObj)
            {
                if (_requestMap.TryGetValue(assetPath, out var request))
                {
                    request.IsCancelled = true;
                    request.CTS?.Cancel();
                    _requestMap.Remove(assetPath);
                }
            }
        }
        
        /// <summary>
        /// 取消所有预加载请求
        /// </summary>
        public void CancelAll()
        {
            lock (_lockObj)
            {
                foreach (var request in _requestMap.Values)
                {
                    request.IsCancelled = true;
                    request.CTS?.Cancel();
                }
                
                _pendingQueue.Clear();
                _activeRequests.Clear();
                _requestMap.Clear();
            }
        }
        
        /// <summary>
        /// 暂停预加载
        /// </summary>
        public void Pause()
        {
            _isRunning = false;
        }
        
        /// <summary>
        /// 恢复预加载
        /// </summary>
        public void Resume()
        {
            if (!_isRunning && _config.EnablePreload)
            {
                StartPreloading();
            }
        }
        
        /// <summary>
        /// 记录资源访问（用于智能预测）
        /// </summary>
        public void RecordAccess(string assetPath)
        {
            _predictor.RecordAccess(assetPath);
        }
        
        /// <summary>
        /// 获取预测的预加载资源
        /// </summary>
        public List<string> GetPredictedAssets(string currentAsset, int maxCount = 5)
        {
            return _predictor.Predict(currentAsset, maxCount);
        }
        
        #endregion
        
        #region 内部方法
        
        /// <summary>
        /// 开始预加载处理
        /// </summary>
        private void StartPreloading()
        {
            _isRunning = true;
            ProcessQueueAsync().Forget();
        }
        
        /// <summary>
        /// 处理预加载队列
        /// </summary>
        private async UniTaskVoid ProcessQueueAsync()
        {
            while (_isRunning)
            {
                // 检查内存状态
                var memoryState = _memoryMonitor.GetMemoryState();
                if (memoryState == MemoryState.Critical)
                {
                    // 内存紧张，暂停预加载
                    await UniTask.Delay(1000, cancellationToken: _cts.Token);
                    continue;
                }
                
                // 填充活动任务
                while (_activeRequests.Count < _config.MaxPreloadTasks)
                {
                    PreloadRequest request;
                    lock (_lockObj)
                    {
                        if (_pendingQueue.Count == 0) break;
                        
                        // 内存警告时只处理高优先级
                        if (memoryState == MemoryState.Warning)
                        {
                            var peek = _pendingQueue.Peek();
                            if (peek.Priority < PreloadPriority.High) break;
                        }
                        
                        request = _pendingQueue.Dequeue();
                        if (request.IsCancelled) continue;
                        
                        _activeRequests.Add(request);
                    }
                    
                    // 执行预加载
                    PreloadAssetAsync(request).Forget();
                }
                
                await UniTask.Delay(100, cancellationToken: _cts.Token);
            }
        }
        
        /// <summary>
        /// 预加载单个资源
        /// </summary>
        private async UniTaskVoid PreloadAssetAsync(PreloadRequest request)
        {
            try
            {
                using (var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
                    _cts.Token, request.CTS.Token))
                {
                    // 执行加载
                    var asset = await LWAssets.LoadAssetAsync<UnityEngine.Object>(
                        request.AssetPath, linkedCts.Token);
                    
                    if (asset != null)
                    {
                        lock (_lockObj)
                        {
                            _preloadedAssets.Add(request.AssetPath);
                        }
                        
                        request.IsCompleted = true;
                        OnAssetPreloaded?.Invoke(request.AssetPath);
                        
                        if (_config.EnableDetailLog)
                        {
                            Debug.Log($"[LWAssets] Preloaded: {request.AssetPath}");
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // 取消，不报错
            }
            catch (Exception ex)
            {
                OnPreloadFailed?.Invoke(request.AssetPath);
                
                if (_config.EnableDetailLog)
                {
                    Debug.LogWarning($"[LWAssets] Preload failed: {request.AssetPath}, Error: {ex.Message}");
                }
            }
            finally
            {
                lock (_lockObj)
                {
                    _activeRequests.Remove(request);
                    _requestMap.Remove(request.AssetPath);
                }
            }
        }
        
        #endregion
        
        public void Dispose()
        {
            _isRunning = false;
            _cts?.Cancel();
            _cts?.Dispose();
            CancelAll();
            _memoryMonitor?.Dispose();
        }
    }
    
    /// <summary>
    /// 简单优先级队列
    /// </summary>
    public class PriorityQueue<T>
    {
        private readonly List<T> _items = new List<T>();
        private readonly Comparison<T> _comparison;
        
        public int Count => _items.Count;
        
        public PriorityQueue(Comparison<T> comparison)
        {
            _comparison = comparison;
        }
        
        public void Enqueue(T item)
        {
            _items.Add(item);
            _items.Sort(_comparison);
        }
        
        public T Dequeue()
        {
            if (_items.Count == 0) return default;
            var item = _items[0];
            _items.RemoveAt(0);
            return item;
        }
        
        public T Peek()
        {
            return _items.Count > 0 ? _items[0] : default;
        }
        
        public void Clear()
        {
            _items.Clear();
        }
    }
}
15. 智能预测器
csharp

// Runtime/Preload/PreloadPredictor.cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace LWAssets
{
    /// <summary>
    /// 预加载预测器 - 基于访问模式预测可能需要的资源
    /// </summary>
    public class PreloadPredictor
    {
        /// <summary>
        /// 访问记录
        /// </summary>
        private class AccessRecord
        {
            public string AssetPath;
            public DateTime LastAccessTime;
            public int AccessCount;
            public List<string> NextAssets = new List<string>(); // 之后访问的资源
        }
        
        private readonly Dictionary<string, AccessRecord> _records = new Dictionary<string, AccessRecord>();
        private readonly List<string> _recentAccesses = new List<string>();
        private const int MaxRecentAccesses = 100;
        private const int MaxNextAssets = 20;
        
        /// <summary>
        /// 记录资源访问
        /// </summary>
        public void RecordAccess(string assetPath)
        {
            if (string.IsNullOrEmpty(assetPath)) return;
            
            // 更新访问记录
            if (!_records.TryGetValue(assetPath, out var record))
            {
                record = new AccessRecord { AssetPath = assetPath };
                _records[assetPath] = record;
            }
            
            record.LastAccessTime = DateTime.Now;
            record.AccessCount++;
            
            // 更新之前资源的"下一个访问"
            if (_recentAccesses.Count > 0)
            {
                var lastAccess = _recentAccesses[_recentAccesses.Count - 1];
                if (_records.TryGetValue(lastAccess, out var lastRecord))
                {
                    if (!lastRecord.NextAssets.Contains(assetPath))
                    {
                        lastRecord.NextAssets.Add(assetPath);
                        if (lastRecord.NextAssets.Count > MaxNextAssets)
                        {
                            lastRecord.NextAssets.RemoveAt(0);
                        }
                    }
                }
            }
            
            // 添加到最近访问
            _recentAccesses.Add(assetPath);
            if (_recentAccesses.Count > MaxRecentAccesses)
            {
                _recentAccesses.RemoveAt(0);
            }
        }
        
        /// <summary>
        /// 预测可能需要的资源
        /// </summary>
        public List<string> Predict(string currentAsset, int maxCount = 5)
        {
            var predictions = new Dictionary<string, float>();
            
            if (!string.IsNullOrEmpty(currentAsset) && _records.TryGetValue(currentAsset, out var record))
            {
                // 基于访问模式预测
                foreach (var next in record.NextAssets)
                {
                    if (!predictions.ContainsKey(next))
                    {
                        predictions[next] = 0;
                    }
                    predictions[next] += 1.0f;
                }
            }
            
            // 基于访问频率补充
            var frequentAssets = _records.Values
                .OrderByDescending(r => r.AccessCount)
                .Take(maxCount * 2);
            
            foreach (var r in frequentAssets)
            {
                if (r.AssetPath == currentAsset) continue;
                
                if (!predictions.ContainsKey(r.AssetPath))
                {
                    predictions[r.AssetPath] = 0;
                }
                predictions[r.AssetPath] += r.AccessCount * 0.1f;
            }
            
            // 基于时间衰减的最近访问
            var recentWeight = 1.0f;
            for (int i = _recentAccesses.Count - 1; i >= 0 && i >= _recentAccesses.Count - 10; i--)
            {
                var asset = _recentAccesses[i];
                if (asset == currentAsset) continue;
                
                if (!predictions.ContainsKey(asset))
                {
                    predictions[asset] = 0;
                }
                predictions[asset] += recentWeight * 0.5f;
                recentWeight *= 0.8f;
            }
            
            // 排序并返回
            return predictions
                .OrderByDescending(p => p.Value)
                .Take(maxCount)
                .Select(p => p.Key)
                .ToList();
        }
        
        /// <summary>
        /// 清除所有记录
        /// </summary>
        public void Clear()
        {
            _records.Clear();
            _recentAccesses.Clear();
        }
    }
}
16. 内存监控器
csharp

// Runtime/Preload/MemoryMonitor.cs
using System;
using UnityEngine;
using UnityEngine.Profiling;
using Cysharp.Threading.Tasks;

namespace LWAssets
{
    /// <summary>
    /// 内存状态
    /// </summary>
    public enum MemoryState
    {
        Normal,
        Warning,
        Critical
    }
    
    /// <summary>
    /// 内存监控器
    /// </summary>
    public class MemoryMonitor : IDisposable
    {
        private readonly LWAssetsConfig _config;
        private MemoryState _currentState = MemoryState.Normal;
        private long _lastUsedMemory;
        private DateTime _lastCheckTime;
        
        public MemoryState CurrentState => _currentState;
        public long UsedMemory => _lastUsedMemory;
        
        public event Action<MemoryState> OnMemoryStateChanged;
        public event Action OnMemoryWarning;
        public event Action OnMemoryCritical;
        
        public MemoryMonitor(LWAssetsConfig config)
        {
            _config = config;
            
            if (_config.EnableAutoUnload)
            {
                StartMonitoring().Forget();
            }
        }
        
        /// <summary>
        /// 获取当前内存状态
        /// </summary>
        public MemoryState GetMemoryState()
        {
            UpdateMemoryState();
            return _currentState;
        }
        
        /// <summary>
        /// 获取内存统计信息
        /// </summary>
        public MemoryStatistics GetStatistics()
        {
            return new MemoryStatistics
            {
                TotalAllocatedMemory = Profiler.GetTotalAllocatedMemoryLong(),
                TotalReservedMemory = Profiler.GetTotalReservedMemoryLong(),
                TotalUnusedReservedMemory = Profiler.GetTotalUnusedReservedMemoryLong(),
                MonoUsedSize = Profiler.GetMonoUsedSizeLong(),
                MonoHeapSize = Profiler.GetMonoHeapSizeLong(),
                TempAllocatorSize = Profiler.GetTempAllocatorSize(),
                GraphicsMemory = Profiler.GetAllocatedMemoryForGraphicsDriver(),
                State = _currentState
            };
        }
        
        /// <summary>
        /// 开始监控
        /// </summary>
        private async UniTaskVoid StartMonitoring()
        {
            while (true)
            {
                await UniTask.Delay(1000);
                
                var previousState = _currentState;
                UpdateMemoryState();
                
                if (_currentState != previousState)
                {
                    OnMemoryStateChanged?.Invoke(_currentState);
                    
                    if (_currentState == MemoryState.Warning)
                    {
                        OnMemoryWarning?.Invoke();
                    }
                    else if (_currentState == MemoryState.Critical)
                    {
                        OnMemoryCritical?.Invoke();
                        
                        // 自动卸载
                        if (_config.EnableAutoUnload)
                        {
                            await LWAssets.UnloadUnusedAssetsAsync();
                        }
                    }
                }
            }
        }
        
        /// <summary>
        /// 更新内存状态
        /// </summary>
        private void UpdateMemoryState()
        {
            _lastUsedMemory = Profiler.GetTotalAllocatedMemoryLong();
            _lastCheckTime = DateTime.Now;
            
            if (_lastUsedMemory >= _config.MemoryCriticalThreshold)
            {
                _currentState = MemoryState.Critical;
            }
            else if (_lastUsedMemory >= _config.MemoryWarningThreshold)
            {
                _currentState = MemoryState.Warning;
            }
            else
            {
                _currentState = MemoryState.Normal;
            }
        }
        
        public void Dispose()
        {
        }
    }
    
    /// <summary>
    /// 内存统计信息
    /// </summary>
    public struct MemoryStatistics
    {
        public long TotalAllocatedMemory;
        public long TotalReservedMemory;
        public long TotalUnusedReservedMemory;
        public long MonoUsedSize;
        public long MonoHeapSize;
        public long TempAllocatorSize;
        public long GraphicsMemory;
        public MemoryState State;
        
        public string GetFormattedAllocatedMemory() => FormatBytes(TotalAllocatedMemory);
        public string GetFormattedReservedMemory() => FormatBytes(TotalReservedMemory);
        public string GetFormattedMonoUsedSize() => FormatBytes(MonoUsedSize);
        
        private static string FormatBytes(long bytes)
        {
            if (bytes >= 1024 * 1024 * 1024)
                return $"{bytes / 1024.0 / 1024.0 / 1024.0:F2} GB";
            if (bytes >= 1024 * 1024)
                return $"{bytes / 1024.0 / 1024.0:F2} MB";
            if (bytes >= 1024)
                return $"{bytes / 1024.0:F2} KB";
            return $"{bytes} B";
        }
    }
}
17. 工具类
csharp

// Runtime/Utility/HashUtility.cs
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace LWAssets
{
    /// <summary>
    /// 哈希工具类
    /// </summary>
    public static class HashUtility
    {
        /// <summary>
        /// 计算字符串的MD5
        /// </summary>
        public static string ComputeMD5(string input)
        {
            using (var md5 = MD5.Create())
            {
                var bytes = Encoding.UTF8.GetBytes(input);
                var hash = md5.ComputeHash(bytes);
                return BitConverter.ToString(hash).Replace("-", "").ToLower();
            }
        }
        
        /// <summary>
        /// 计算字节数组的MD5
        /// </summary>
        public static string ComputeMD5(byte[] data)
        {
            using (var md5 = MD5.Create())
            {
                var hash = md5.ComputeHash(data);
                return BitConverter.ToString(hash).Replace("-", "").ToLower();
            }
        }
        
        /// <summary>
        /// 计算文件的MD5
        /// </summary>
        public static string ComputeFileMD5(string filePath)
        {
            if (!File.Exists(filePath)) return null;
            
            using (var stream = File.OpenRead(filePath))
            using (var md5 = MD5.Create())
            {
                var hash = md5.ComputeHash(stream);
                return BitConverter.ToString(hash).Replace("-", "").ToLower();
            }
        }
        
        /// <summary>
        /// 计算文件的CRC32
        /// </summary>
        public static uint ComputeFileCRC32(string filePath)
        {
            if (!File.Exists(filePath)) return 0;
            
            var data = File.ReadAllBytes(filePath);
            return ComputeCRC32(data);
        }
        
        /// <summary>
        /// 计算CRC32
        /// </summary>
        public static uint ComputeCRC32(byte[] data)
        {
            uint crc = 0xFFFFFFFF;
            
            foreach (byte b in data)
            {
                crc ^= b;
                for (int i = 0; i < 8; i++)
                {
                    crc = (crc >> 1) ^ (0xEDB88320 * (crc & 1));
                }
            }
            
            return crc ^ 0xFFFFFFFF;
        }
    }
}

// Runtime/Utility/FileUtility.cs
using System;
using System.IO;
using System.Threading.Tasks;

namespace LWAssets
{
    /// <summary>
    /// 文件工具类
    /// </summary>
    public static class FileUtility
    {
        /// <summary>
        /// 确保目录存在
        /// </summary>
        public static void EnsureDirectory(string path)
        {
            var directory = Path.GetDirectoryName(path);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }
        }
        
        /// <summary>
        /// 安全删除文件
        /// </summary>
        public static bool SafeDelete(string path)
        {
            try
            {
                if (File.Exists(path))
                {
                    File.Delete(path);
                }
                return true;
            }
            catch
            {
                return false;
            }
        }
        
        /// <summary>
        /// 安全移动文件
        /// </summary>
        public static bool SafeMove(string source, string destination)
        {
            try
            {
                EnsureDirectory(destination);
                SafeDelete(destination);
                File.Move(source, destination);
                return true;
            }
            catch
            {
                return false;
            }
        }
        
        /// <summary>
        /// 获取文件大小
        /// </summary>
        public static long GetFileSize(string path)
        {
            if (!File.Exists(path)) return 0;
            return new FileInfo(path).Length;
        }
        
        /// <summary>
        /// 格式化文件大小
        /// </summary>
        public static string FormatFileSize(long bytes)
        {
            string[] sizes = { "B", "KB", "MB", "GB", "TB" };
            int order = 0;
            double size = bytes;
            
            while (size >= 1024 && order < sizes.Length - 1)
            {
                order++;
                size /= 1024;
            }
            
            return $"{size:0.##} {sizes[order]}";
        }
        
        /// <summary>
        /// 复制目录
        /// </summary>
        public static void CopyDirectory(string source, string destination, bool overwrite = true)
        {
            if (!Directory.Exists(source)) return;
            
            if (!Directory.Exists(destination))
            {
                Directory.CreateDirectory(destination);
            }
            
            foreach (var file in Directory.GetFiles(source))
            {
                var destFile = Path.Combine(destination, Path.GetFileName(file));
                File.Copy(file, destFile, overwrite);
            }
            
            foreach (var dir in Directory.GetDirectories(source))
            {
                var destDir = Path.Combine(destination, Path.GetFileName(dir));
                CopyDirectory(dir, destDir, overwrite);
            }
        }
    }
}
18. 编辑器 - 构建系统
csharp

// Editor/Build/LWAssetsBuildPipeline.cs
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEditor.Build.Pipeline;
using UnityEngine;

namespace LWAssets.Editor
{
    /// <summary>
    /// 构建配置
    /// </summary>
    [CreateAssetMenu(fileName = "LWAssetsBuildConfig", menuName = "LWAssets/Build Config")]
    public class LWAssetsBuildConfig : ScriptableObject
    {
        [Header("基础设置")]
        public string OutputPath = "AssetBundles";
        public BuildTarget BuildTarget = BuildTarget.StandaloneWindows64;
        public BuildAssetBundleOptions BuildOptions = BuildAssetBundleOptions.ChunkBasedCompression;
        
        [Header("分包规则")]
        public List<PackageRule> PackageRules = new List<PackageRule>();
        
        [Header("Shader处理")]
        public bool CollectShaders = true;
        public string ShaderBundleName = "shaders";
        public List<string> ShaderVariantCollections = new List<string>();
        
        [Header("标签设置")]
        public List<TagRule> TagRules = new List<TagRule>();
        
        [Header("高级设置")]
        public bool EnableEncryption = false;
        public string EncryptionKey = "";
        public bool GenerateReport = true;
    }
    
    /// <summary>
    /// 分包规则
    /// </summary>
    [Serializable]
    public class PackageRule
    {
        public string Name;
        public PackageStrategy Strategy;
        public string FolderPath;
        public string FilePattern = "*";
        public long MaxBundleSize = 10 * 1024 * 1024; // 10MB
        public int Priority = 0;
        public List<string> Tags = new List<string>();
    }
    
    /// <summary>
    /// 分包策略
    /// </summary>
    public enum PackageStrategy
    {
        /// <summary>
        /// 按文件夹打包
        /// </summary>
        ByFolder,
        
        /// <summary>
        /// 每个文件单独打包
        /// </summary>
        ByFile,
        
        /// <summary>
        /// 按大小分包
        /// </summary>
        BySize,
        
        /// <summary>
        /// 按优先级分包
        /// </summary>
        ByPriority,
        
        /// <summary>
        /// 原始文件（不打包）
        /// </summary>
        RawFile
    }
    
    /// <summary>
    /// 标签规则
    /// </summary>
    [Serializable]
    public class TagRule
    {
        public string FolderPath;
        public List<string> Tags = new List<string>();
    }
    
    /// <summary>
    /// 构建管线
    /// </summary>
    public static class LWAssetsBuildPipeline
    {
        /// <summary>
        /// 执行构建
        /// </summary>
        public static void Build(LWAssetsBuildConfig config)
        {
            if (config == null)
            {
                Debug.LogError("[LWAssets] Build config is null!");
                return;
            }
            
            var startTime = DateTime.Now;
            Debug.Log("[LWAssets] Build started...");
            
            try
            {
                // 1. 收集资源
                var bundleBuilds = CollectAssets(config);
                
                // 2. 处理Shader
                if (config.CollectShaders)
                {
                    var shaderBuild = CollectShaders(config);
                    if (shaderBuild.assetNames.Length > 0)
                    {
                        bundleBuilds.Add(shaderBuild);
                    }
                }
                
                // 3. 构建AssetBundle
                var outputPath = GetOutputPath(config);
                if (!Directory.Exists(outputPath))
                {
                    Directory.CreateDirectory(outputPath);
                }
                
                var manifest = BuildPipeline.BuildAssetBundles(
                    outputPath,
                    bundleBuilds.ToArray(),
                    config.BuildOptions,
                    config.BuildTarget);
                
                if (manifest == null)
                {
                    Debug.LogError("[LWAssets] Build failed!");
                    return;
                }
                
                // 4. 生成清单文件
                var bundleManifest = GenerateManifest(config, manifest, outputPath);
                
                // 5. 生成版本文件
                GenerateVersionFile(config, bundleManifest, outputPath);
                
                // 6. 清理多余文件
                CleanupOutputPath(outputPath, bundleManifest);
                
                // 7. 生成报告
                if (config.GenerateReport)
                {
                    GenerateBuildReport(config, bundleManifest, outputPath);
                }
                
                var elapsed = DateTime.Now - startTime;
                Debug.Log($"[LWAssets] Build completed in {elapsed.TotalSeconds:F2}s");
                
                AssetDatabase.Refresh();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[LWAssets] Build error: {ex.Message}\n{ex.StackTrace}");
            }
        }
        
        /// <summary>
        /// 收集资源
        /// </summary>
        private static List<AssetBundleBuild> CollectAssets(LWAssetsBuildConfig config)
        {
            var builds = new List<AssetBundleBuild>();
            var processedAssets = new HashSet<string>();
            
            foreach (var rule in config.PackageRules)
            {
                if (string.IsNullOrEmpty(rule.FolderPath)) continue;
                if (!Directory.Exists(rule.FolderPath)) continue;
                
                var assets = Directory.GetFiles(rule.FolderPath, rule.FilePattern, SearchOption.AllDirectories)
                    .Where(f => !f.EndsWith(".meta"))
                    .Where(f => !processedAssets.Contains(f))
                    .Select(f => f.Replace("\\", "/"))
                    .ToList();
                
                switch (rule.Strategy)
                {
                    case PackageStrategy.ByFolder:
                        builds.AddRange(PackageByFolder(rule, assets));
                        break;
                        
                    case PackageStrategy.ByFile:
                        builds.AddRange(PackageByFile(rule, assets));
                        break;
                        
                    case PackageStrategy.BySize:
                        builds.AddRange(PackageBySize(rule, assets));
                        break;
                        
                    case PackageStrategy.RawFile:
                        // 原始文件不加入AssetBundle，但需要记录
                        break;
                }
                
                foreach (var asset in assets)
                {
                    processedAssets.Add(asset);
                }
            }
            
            return builds;
        }
        
        




继续

claude-opus-4-5-20251101
LWAssets - Unity3D 资源管理系统
我将为您开发一套完整的资源管理系统。这是一个大型系统，我会按模块逐步实现。

项目结构
text

Assets/
└── LWAssets/
    ├── Runtime/
    │   ├── Core/
    │   │   ├── LWAssets.cs                    # 主入口
    │   │   ├── LWAssetsConfig.cs              # 配置系统
    │   │   ├── AssetHandle.cs                 # 资源句柄
    │   │   ├── BundleHandle.cs                # Bundle句柄
    │   │   └── AssetReference.cs              # 资源引用
    │   ├── Loader/
    │   │   ├── IAssetLoader.cs                # 加载器接口
    │   │   ├── EditorSimulateLoader.cs        # 编辑器模拟加载
    │   │   ├── OfflineLoader.cs               # 离线加载
    │   │   ├── OnlineLoader.cs                # 联机加载
    │   │   └── WebGLLoader.cs                 # WebGL加载
    │   ├── Download/
    │   │   ├── DownloadManager.cs             # 下载管理器
    │   │   ├── DownloadTask.cs                # 下载任务
    │   │   ├── BreakpointResume.cs            # 断点续传
    │   │   └── DownloadQueue.cs               # 下载队列
    │   ├── Cache/
    │   │   ├── CacheManager.cs                # 缓存管理
    │   │   ├── VersionManager.cs              # 版本管理
    │   │   └── CachePolicy.cs                 # 缓存策略
    │   ├── Preload/
    │   │   ├── PreloadManager.cs              # 预加载管理
    │   │   ├── PreloadPredictor.cs            # 智能预测
    │   │   └── MemoryMonitor.cs               # 内存监控
    │   ├── Bundle/
    │   │   ├── BundleManifest.cs              # 清单文件
    │   │   ├── BundleInfo.cs                  # Bundle信息
    │   │   └── DependencyResolver.cs          # 依赖解析
    │   └── Utility/
    │       ├── AsyncOperationExtensions.cs    # 异步扩展
    │       ├── FileUtility.cs                 # 文件工具
    │       └── HashUtility.cs                 # 哈希工具
    ├── Editor/
    │   ├── Build/
    │   │   ├── LWAssetsBuildPipeline.cs       # 构建管线
    │   │   ├── BundleBuilder.cs               # Bundle构建器
    │   │   ├── PackageStrategy.cs             # 分包策略
    │   │   └── ShaderProcessor.cs             # Shader处理
    │   ├── Inspector/
    │   │   ├── AssetAnalyzer.cs               # 资源分析
    │   │   ├── BundleViewer.cs                # Bundle查看器
    │   │   └── DependencyViewer.cs            # 依赖查看器
    │   └── Window/
    │       ├── LWAssetsWindow.cs              # 主窗口
    │       └── BuildSettingsWindow.cs         # 构建设置窗口
    └── Samples/
        └── Demo/
            └── LWAssetsDemo.cs                # 使用示例
核心实现
1. 核心系统 - 主入口
csharp

// Runtime/Core/LWAssets.cs
using System;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;
using Cysharp.Threading.Tasks;

namespace LWAssets
{
    /// <summary>
    /// LWAssets 资源管理系统主入口
    /// </summary>
    public static class LWAssets
    {
        #region 属性与字段
        
        private static IAssetLoader _loader;
        private static LWAssetsConfig _config;
        private static DownloadManager _downloadManager;
        private static CacheManager _cacheManager;
        private static PreloadManager _preloadManager;
        private static VersionManager _versionManager;
        private static BundleManifest _manifest;
        
        private static bool _isInitialized;
        private static readonly object _lockObj = new object();
        
        /// <summary>
        /// 是否已初始化
        /// </summary>
        public static bool IsInitialized => _isInitialized;
        
        /// <summary>
        /// 当前运行模式
        /// </summary>
        public static PlayMode CurrentPlayMode => _config?.PlayMode ?? PlayMode.EditorSimulate;
        
        /// <summary>
        /// 下载管理器
        /// </summary>
        public static DownloadManager Downloader => _downloadManager;
        
        /// <summary>
        /// 缓存管理器
        /// </summary>
        public static CacheManager Cache => _cacheManager;
        
        /// <summary>
        /// 预加载管理器
        /// </summary>
        public static PreloadManager Preloader => _preloadManager;
        
        /// <summary>
        /// 版本管理器
        /// </summary>
        public static VersionManager Version => _versionManager;
        
        #endregion
        
        #region 初始化
        
        /// <summary>
        /// 初始化资源系统
        /// </summary>
        public static async UniTask InitializeAsync(LWAssetsConfig config = null)
        {
            if (_isInitialized)
            {
                Debug.LogWarning("[LWAssets] Already initialized!");
                return;
            }
            
            lock (_lockObj)
            {
                if (_isInitialized) return;
                
                _config = config ?? LWAssetsConfig.Load();
                
                // 初始化各子系统
                _cacheManager = new CacheManager(_config);
                _versionManager = new VersionManager(_config, _cacheManager);
                _downloadManager = new DownloadManager(_config);
                _preloadManager = new PreloadManager(_config);
                
                // 根据运行模式创建加载器
                _loader = CreateLoader(_config.PlayMode);
            }
            
            // 初始化版本信息
            await _versionManager.InitializeAsync();
            
            // 加载清单文件
            _manifest = await LoadManifestAsync();
            
            // 初始化加载器
            await _loader.InitializeAsync(_manifest);
            
            _isInitialized = true;
            Debug.Log($"[LWAssets] Initialized with {_config.PlayMode} mode");
        }
        
        /// <summary>
        /// 创建对应模式的加载器
        /// </summary>
        private static IAssetLoader CreateLoader(PlayMode mode)
        {
            switch (mode)
            {
                case PlayMode.EditorSimulate:
                    #if UNITY_EDITOR
                    return new EditorSimulateLoader(_config);
                    #else
                    Debug.LogWarning("[LWAssets] EditorSimulate mode not available in build, fallback to Offline");
                    return new OfflineLoader(_config, _cacheManager, _downloadManager);
                    #endif
                    
                case PlayMode.Offline:
                    return new OfflineLoader(_config, _cacheManager, _downloadManager);
                    
                case PlayMode.Online:
                    return new OnlineLoader(_config, _cacheManager, _downloadManager, _versionManager);
                    
                case PlayMode.WebGL:
                    return new WebGLLoader(_config, _cacheManager, _downloadManager);
                    
                default:
                    throw new ArgumentOutOfRangeException(nameof(mode));
            }
        }
        
        /// <summary>
        /// 加载清单文件
        /// </summary>
        private static async UniTask<BundleManifest> LoadManifestAsync()
        {
            if (_config.PlayMode == PlayMode.EditorSimulate)
            {
                #if UNITY_EDITOR
                return await EditorManifestBuilder.BuildAsync();
                #endif
            }
            
            return await _versionManager.LoadManifestAsync();
        }
        
        #endregion
        
        #region 同步加载API
        
        /// <summary>
        /// 同步加载资源
        /// </summary>
        public static T LoadAsset<T>(string assetPath) where T : UnityEngine.Object
        {
            CheckInitialized();
            return _loader.LoadAsset<T>(assetPath);
        }
        
        /// <summary>
        /// 同步加载资源（返回句柄）
        /// </summary>
        public static AssetHandle<T> LoadAssetWithHandle<T>(string assetPath) where T : UnityEngine.Object
        {
            CheckInitialized();
            return _loader.LoadAssetWithHandle<T>(assetPath);
        }
        
        /// <summary>
        /// 同步加载原始文件
        /// </summary>
        public static byte[] LoadRawFile(string assetPath)
        {
            CheckInitialized();
            return _loader.LoadRawFile(assetPath);
        }
        
        /// <summary>
        /// 同步加载原始文件为文本
        /// </summary>
        public static string LoadRawFileText(string assetPath)
        {
            CheckInitialized();
            return _loader.LoadRawFileText(assetPath);
        }
        
        #endregion
        
        #region 异步加载API (UniTask)
        
        /// <summary>
        /// 异步加载资源
        /// </summary>
        public static async UniTask<T> LoadAssetAsync<T>(string assetPath, 
            CancellationToken cancellationToken = default) where T : UnityEngine.Object
        {
            CheckInitialized();
            return await _loader.LoadAssetAsync<T>(assetPath, cancellationToken);
        }
        
        /// <summary>
        /// 异步加载资源（返回句柄）
        /// </summary>
        public static async UniTask<AssetHandle<T>> LoadAssetWithHandleAsync<T>(string assetPath,
            CancellationToken cancellationToken = default) where T : UnityEngine.Object
        {
            CheckInitialized();
            return await _loader.LoadAssetWithHandleAsync<T>(assetPath, cancellationToken);
        }
        
        /// <summary>
        /// 异步加载原始文件
        /// </summary>
        public static async UniTask<byte[]> LoadRawFileAsync(string assetPath,
            CancellationToken cancellationToken = default)
        {
            CheckInitialized();
            return await _loader.LoadRawFileAsync(assetPath, cancellationToken);
        }
        
        /// <summary>
        /// 异步加载原始文件为文本
        /// </summary>
        public static async UniTask<string> LoadRawFileTextAsync(string assetPath,
            CancellationToken cancellationToken = default)
        {
            CheckInitialized();
            return await _loader.LoadRawFileTextAsync(assetPath, cancellationToken);
        }
        
        /// <summary>
        /// 异步加载场景
        /// </summary>
        public static async UniTask<SceneHandle> LoadSceneAsync(string scenePath, 
            UnityEngine.SceneManagement.LoadSceneMode mode = UnityEngine.SceneManagement.LoadSceneMode.Single,
            bool activateOnLoad = true,
            CancellationToken cancellationToken = default)
        {
            CheckInitialized();
            return await _loader.LoadSceneAsync(scenePath, mode, activateOnLoad, cancellationToken);
        }
        
        /// <summary>
        /// 批量异步加载资源
        /// </summary>
        public static async UniTask<T[]> LoadAssetsAsync<T>(string[] assetPaths,
            IProgress<float> progress = null,
            CancellationToken cancellationToken = default) where T : UnityEngine.Object
        {
            CheckInitialized();
            
            var results = new T[assetPaths.Length];
            var completedCount = 0;
            
            var tasks = new UniTask<T>[assetPaths.Length];
            for (int i = 0; i < assetPaths.Length; i++)
            {
                int index = i;
                tasks[i] = LoadAssetAsync<T>(assetPaths[i], cancellationToken)
                    .ContinueWith(asset =>
                    {
                        results[index] = asset;
                        Interlocked.Increment(ref completedCount);
                        progress?.Report((float)completedCount / assetPaths.Length);
                        return asset;
                    });
            }
            
            await UniTask.WhenAll(tasks);
            return results;
        }
        
        #endregion
        
        #region 资源管理
        
        /// <summary>
        /// 释放资源
        /// </summary>
        public static void Release(UnityEngine.Object asset)
        {
            CheckInitialized();
            _loader.Release(asset);
        }
        
        /// <summary>
        /// 释放所有未使用资源
        /// </summary>
        public static async UniTask UnloadUnusedAssetsAsync()
        {
            CheckInitialized();
            await _loader.UnloadUnusedAssetsAsync();
            await Resources.UnloadUnusedAssets();
            GC.Collect();
        }
        
        /// <summary>
        /// 强制卸载所有资源
        /// </summary>
        public static void ForceUnloadAll()
        {
            CheckInitialized();
            _loader.ForceUnloadAll();
        }
        
        #endregion
        
        #region 下载相关
        
        /// <summary>
        /// 获取资源包下载大小
        /// </summary>
        public static async UniTask<long> GetDownloadSizeAsync(string[] tags = null)
        {
            CheckInitialized();
            return await _versionManager.GetDownloadSizeAsync(tags);
        }
        
        /// <summary>
        /// 下载资源包
        /// </summary>
        public static async UniTask DownloadAsync(string[] tags = null, 
            IProgress<DownloadProgress> progress = null,
            CancellationToken cancellationToken = default)
        {
            CheckInitialized();
            
            var bundles = await _versionManager.GetBundlesToDownloadAsync(tags);
            await _downloadManager.DownloadAsync(bundles, progress, cancellationToken);
        }
        
        #endregion
        
        #region 工具方法
        
        private static void CheckInitialized()
        {
            if (!_isInitialized)
            {
                throw new InvalidOperationException("[LWAssets] Not initialized! Call InitializeAsync first.");
            }
        }
        
        /// <summary>
        /// 销毁资源系统
        /// </summary>
        public static void Destroy()
        {
            if (!_isInitialized) return;
            
            _loader?.Dispose();
            _downloadManager?.Dispose();
            _cacheManager?.Dispose();
            _preloadManager?.Dispose();
            
            _loader = null;
            _downloadManager = null;
            _cacheManager = null;
            _preloadManager = null;
            _versionManager = null;
            _manifest = null;
            _config = null;
            
            _isInitialized = false;
            
            Debug.Log("[LWAssets] Destroyed");
        }
        
        #endregion
    }
}
2. 配置系统
csharp

// Runtime/Core/LWAssetsConfig.cs
using System;
using System.IO;
using UnityEngine;

namespace LWAssets
{
    /// <summary>
    /// 运行模式
    /// </summary>
    public enum PlayMode
    {
        /// <summary>
        /// 编辑器模拟模式 - 直接从AssetDatabase加载
        /// </summary>
        EditorSimulate,
        
        /// <summary>
        /// 离线模式 - 从本地资源包加载
        /// </summary>
        Offline,
        
        /// <summary>
        /// 联机模式 - 从服务器下载资源
        /// </summary>
        Online,
        
        /// <summary>
        /// WebGL模式 - 特殊的WebGL平台处理
        /// </summary>
        WebGL
    }
    
    /// <summary>
    /// LWAssets配置
    /// </summary>
    [CreateAssetMenu(fileName = "LWAssetsConfig", menuName = "LWAssets/Config")]
    public class LWAssetsConfig : ScriptableObject
    {
        #region 基础设置
        
        [Header("基础设置")]
        [SerializeField] private PlayMode _playMode = PlayMode.EditorSimulate;
        
        [SerializeField] private string _buildOutputPath = "AssetBundles";
        
        [SerializeField] private string _remoteURL = "http://localhost:8080/";
        
        [SerializeField] private string _manifestFileName = "manifest.json";
        
        [SerializeField] private string _versionFileName = "version.json";
        
        #endregion
        
        #region 下载设置
        
        [Header("下载设置")]
        [SerializeField] private int _maxConcurrentDownloads = 5;
        
        [SerializeField] private int _downloadTimeout = 30;
        
        [SerializeField] private int _maxRetryCount = 3;
        
        [SerializeField] private float _retryDelay = 1f;
        
        [SerializeField] private bool _enableBreakpointResume = true;
        
        #endregion
        
        #region 缓存设置
        
        [Header("缓存设置")]
        [SerializeField] private long _maxCacheSize = 1024 * 1024 * 1024; // 1GB
        
        [SerializeField] private int _cacheExpirationDays = 30;
        
        [SerializeField] private bool _enableAutoCleanup = true;
        
        [SerializeField] private float _cleanupThreshold = 0.9f; // 缓存使用率达到90%时清理
        
        #endregion
        
        #region 预加载设置
        
        [Header("预加载设置")]
        [SerializeField] private bool _enablePreload = true;
        
        [SerializeField] private int _maxPreloadTasks = 3;
        
        [SerializeField] private long _maxPreloadMemory = 256 * 1024 * 1024; // 256MB
        
        #endregion
        
        #region 内存设置
        
        [Header("内存设置")]
        [SerializeField] private long _memoryWarningThreshold = 512 * 1024 * 1024; // 512MB
        
        [SerializeField] private long _memoryCriticalThreshold = 768 * 1024 * 1024; // 768MB
        
        [SerializeField] private bool _enableAutoUnload = true;
        
        #endregion
        
        #region 调试设置
        
        [Header("调试设置")]
        [SerializeField] private bool _enableDetailLog = false;
        
        [SerializeField] private bool _enableProfiler = false;
        
        #endregion
        
        #region 属性
        
        public PlayMode PlayMode
        {
            get => _playMode;
            set => _playMode = value;
        }
        
        public string BuildOutputPath => _buildOutputPath;
        public string RemoteURL => _remoteURL;
        public string ManifestFileName => _manifestFileName;
        public string VersionFileName => _versionFileName;
        
        public int MaxConcurrentDownloads => _maxConcurrentDownloads;
        public int DownloadTimeout => _downloadTimeout;
        public int MaxRetryCount => _maxRetryCount;
        public float RetryDelay => _retryDelay;
        public bool EnableBreakpointResume => _enableBreakpointResume;
        
        public long MaxCacheSize => _maxCacheSize;
        public int CacheExpirationDays => _cacheExpirationDays;
        public bool EnableAutoCleanup => _enableAutoCleanup;
        public float CleanupThreshold => _cleanupThreshold;
        
        public bool EnablePreload => _enablePreload;
        public int MaxPreloadTasks => _maxPreloadTasks;
        public long MaxPreloadMemory => _maxPreloadMemory;
        
        public long MemoryWarningThreshold => _memoryWarningThreshold;
        public long MemoryCriticalThreshold => _memoryCriticalThreshold;
        public bool EnableAutoUnload => _enableAutoUnload;
        
        public bool EnableDetailLog => _enableDetailLog;
        public bool EnableProfiler => _enableProfiler;
        
        #endregion
        
        #region 路径
        
        /// <summary>
        /// 获取平台名称
        /// </summary>
        public static string GetPlatformName()
        {
            #if UNITY_ANDROID
            return "Android";
            #elif UNITY_IOS
            return "iOS";
            #elif UNITY_WEBGL
            return "WebGL";
            #elif UNITY_STANDALONE_WIN
            return "Windows";
            #elif UNITY_STANDALONE_OSX
            return "MacOS";
            #elif UNITY_STANDALONE_LINUX
            return "Linux";
            #else
            return "Unknown";
            #endif
        }
        
        /// <summary>
        /// 获取StreamingAssets路径
        /// </summary>
        public string GetStreamingAssetsPath()
        {
            return Path.Combine(Application.streamingAssetsPath, _buildOutputPath, GetPlatformName());
        }
        
        /// <summary>
        /// 获取持久化数据路径
        /// </summary>
        public string GetPersistentDataPath()
        {
            return Path.Combine(Application.persistentDataPath, _buildOutputPath, GetPlatformName());
        }
        
        /// <summary>
        /// 获取远程URL
        /// </summary>
        public string GetRemoteURL()
        {
            var url = _remoteURL.TrimEnd('/');
            return $"{url}/{GetPlatformName()}/";
        }
        
        /// <summary>
        /// 获取构建输出路径
        /// </summary>
        public string GetBuildOutputPath()
        {
            return Path.Combine(Application.dataPath, "..", _buildOutputPath, GetPlatformName());
        }
        
        #endregion
        
        #region 加载配置
        
        private const string CONFIG_PATH = "LWAssets/LWAssetsConfig";
        
        /// <summary>
        /// 加载配置
        /// </summary>
        public static LWAssetsConfig Load()
        {
            var config = Resources.Load<LWAssetsConfig>(CONFIG_PATH);
            if (config == null)
            {
                Debug.LogWarning($"[LWAssets] Config not found at Resources/{CONFIG_PATH}, using default config");
                config = CreateInstance<LWAssetsConfig>();
            }
            return config;
        }
        
        #endregion
    }
}
3. 资源句柄
csharp

// Runtime/Core/AssetHandle.cs
using System;
using UnityEngine;

namespace LWAssets
{
    /// <summary>
    /// 资源句柄基类
    /// </summary>
    public abstract class HandleBase : IDisposable
    {
        protected string _assetPath;
        protected int _referenceCount;
        protected bool _isDisposed;
        
        public string AssetPath => _assetPath;
        public int ReferenceCount => _referenceCount;
        public bool IsDisposed => _isDisposed;
        public abstract bool IsValid { get; }
        public abstract bool IsDone { get; }
        public abstract float Progress { get; }
        
        public event Action OnComplete;
        
        protected void InvokeComplete()
        {
            OnComplete?.Invoke();
        }
        
        public void Retain()
        {
            if (_isDisposed)
            {
                Debug.LogWarning($"[LWAssets] Cannot retain disposed handle: {_assetPath}");
                return;
            }
            _referenceCount++;
        }
        
        public void Release()
        {
            if (_isDisposed) return;
            
            _referenceCount--;
            if (_referenceCount <= 0)
            {
                Dispose();
            }
        }
        
        public abstract void Dispose();
    }
    
    /// <summary>
    /// 泛型资源句柄
    /// </summary>
    public class AssetHandle<T> : HandleBase where T : UnityEngine.Object
    {
        private T _asset;
        private bool _isDone;
        private float _progress;
        private Exception _error;
        
        public T Asset => _asset;
        public override bool IsValid => _asset != null;
        public override bool IsDone => _isDone;
        public override float Progress => _progress;
        public Exception Error => _error;
        public bool HasError => _error != null;
        
        public AssetHandle(string assetPath)
        {
            _assetPath = assetPath;
            _referenceCount = 1;
        }
        
        internal void SetAsset(T asset)
        {
            _asset = asset;
            _progress = 1f;
            _isDone = true;
            InvokeComplete();
        }
        
        internal void SetProgress(float progress)
        {
            _progress = Mathf.Clamp01(progress);
        }
        
        internal void SetError(Exception error)
        {
            _error = error;
            _isDone = true;
            InvokeComplete();
        }
        
        public override void Dispose()
        {
            if (_isDisposed) return;
            
            _isDisposed = true;
            
            if (_asset != null)
            {
                LWAssets.Release(_asset);
                _asset = null;
            }
        }
        
        /// <summary>
        /// 隐式转换为资源类型
        /// </summary>
        public static implicit operator T(AssetHandle<T> handle)
        {
            return handle?.Asset;
        }
    }
    
    /// <summary>
    /// 场景句柄
    /// </summary>
    public class SceneHandle : HandleBase
    {
        private UnityEngine.SceneManagement.Scene _scene;
        private bool _isDone;
        private float _progress;
        private Exception _error;
        
        public UnityEngine.SceneManagement.Scene Scene => _scene;
        public override bool IsValid => _scene.IsValid();
        public override bool IsDone => _isDone;
        public override float Progress => _progress;
        public Exception Error => _error;
        public bool HasError => _error != null;
        
        public SceneHandle(string scenePath)
        {
            _assetPath = scenePath;
            _referenceCount = 1;
        }
        
        internal void SetScene(UnityEngine.SceneManagement.Scene scene)
        {
            _scene = scene;
            _progress = 1f;
            _isDone = true;
            InvokeComplete();
        }
        
        internal void SetProgress(float progress)
        {
            _progress = Mathf.Clamp01(progress);
        }
        
        internal void SetError(Exception error)
        {
            _error = error;
            _isDone = true;
            InvokeComplete();
        }
        
        /// <summary>
        /// 卸载场景
        /// </summary>
        public async Cysharp.Threading.Tasks.UniTask UnloadAsync()
        {
            if (!_scene.IsValid()) return;
            
            var op = UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync(_scene);
            await op;
        }
        
        public override void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
        }
    }
    
    /// <summary>
    /// 原始文件句柄
    /// </summary>
    public class RawFileHandle : HandleBase
    {
        private byte[] _data;
        private bool _isDone;
        private float _progress;
        private Exception _error;
        
        public byte[] Data => _data;
        public string Text => _data != null ? System.Text.Encoding.UTF8.GetString(_data) : null;
        public override bool IsValid => _data != null;
        public override bool IsDone => _isDone;
        public override float Progress => _progress;
        public Exception Error => _error;
        public bool HasError => _error != null;
        
        public RawFileHandle(string assetPath)
        {
            _assetPath = assetPath;
            _referenceCount = 1;
        }
        
        internal void SetData(byte[] data)
        {
            _data = data;
            _progress = 1f;
            _isDone = true;
            InvokeComplete();
        }
        
        internal void SetProgress(float progress)
        {
            _progress = Mathf.Clamp01(progress);
        }
        
        internal void SetError(Exception error)
        {
            _error = error;
            _isDone = true;
            InvokeComplete();
        }
        
        public override void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            _data = null;
        }
    }
}
4. Bundle句柄与信息
csharp

// Runtime/Core/BundleHandle.cs
using System;
using System.Collections.Generic;
using UnityEngine;
using Cysharp.Threading.Tasks;

namespace LWAssets
{
    /// <summary>
    /// Bundle句柄
    /// </summary>
    public class BundleHandle : IDisposable
    {
        private readonly string _bundleName;
        private AssetBundle _bundle;
        private int _referenceCount;
        private bool _isDisposed;
        private readonly List<BundleHandle> _dependencies = new List<BundleHandle>();
        
        public string BundleName => _bundleName;
        public AssetBundle Bundle => _bundle;
        public int ReferenceCount => _referenceCount;
        public bool IsDisposed => _isDisposed;
        public bool IsValid => _bundle != null;
        public IReadOnlyList<BundleHandle> Dependencies => _dependencies;
        
        public BundleHandle(string bundleName)
        {
            _bundleName = bundleName;
            _referenceCount = 0;
        }
        
        internal void SetBundle(AssetBundle bundle)
        {
            _bundle = bundle;
        }
        
        internal void AddDependency(BundleHandle dependency)
        {
            if (dependency != null && !_dependencies.Contains(dependency))
            {
                _dependencies.Add(dependency);
                dependency.Retain();
            }
        }
        
        public void Retain()
        {
            if (_isDisposed)
            {
                Debug.LogWarning($"[LWAssets] Cannot retain disposed bundle: {_bundleName}");
                return;
            }
            _referenceCount++;
        }
        
        public void Release()
        {
            if (_isDisposed) return;
            
            _referenceCount--;
            if (_referenceCount <= 0)
            {
                Dispose();
            }
        }
        
        public void Dispose()
        {
            if (_isDisposed) return;
            
            _isDisposed = true;
            
            // 释放依赖
            foreach (var dep in _dependencies)
            {
                dep.Release();
            }
            _dependencies.Clear();
            
            // 卸载Bundle
            if (_bundle != null)
            {
                _bundle.Unload(true);
                _bundle = null;
            }
        }
    }
}

// Runtime/Bundle/BundleInfo.cs
using System;
using System.Collections.Generic;

namespace LWAssets
{
    /// <summary>
    /// Bundle信息
    /// </summary>
    [Serializable]
    public class BundleInfo
    {
        /// <summary>
        /// Bundle名称
        /// </summary>
        public string BundleName;
        
        /// <summary>
        /// 文件哈希值
        /// </summary>
        public string Hash;
        
        /// <summary>
        /// 文件CRC
        /// </summary>
        public uint CRC;
        
        /// <summary>
        /// 文件大小(字节)
        /// </summary>
        public long Size;
        
        /// <summary>
        /// 是否为原始文件包
        /// </summary>
        public bool IsRawFile;
        
        /// <summary>
        /// 是否加密
        /// </summary>
        public bool IsEncrypted;
        
        /// <summary>
        /// 标签列表
        /// </summary>
        public List<string> Tags = new List<string>();
        
        /// <summary>
        /// 依赖的Bundle名称列表
        /// </summary>
        public List<string> Dependencies = new List<string>();
        
        /// <summary>
        /// 包含的资源路径列表
        /// </summary>
        public List<string> Assets = new List<string>();
        
        /// <summary>
        /// 优先级(0-10, 越高越优先)
        /// </summary>
        public int Priority;
        
        /// <summary>
        /// 获取带哈希的文件名
        /// </summary>
        public string GetFileName()
        {
            return $"{BundleName}_{Hash}";
        }
    }
    
    /// <summary>
    /// 资源信息
    /// </summary>
    [Serializable]
    public class AssetInfo
    {
        /// <summary>
        /// 资源路径
        /// </summary>
        public string AssetPath;
        
        /// <summary>
        /// 资源类型
        /// </summary>
        public string AssetType;
        
        /// <summary>
        /// 所属Bundle名称
        /// </summary>
        public string BundleName;
        
        /// <summary>
        /// 是否为原始文件
        /// </summary>
        public bool IsRawFile;
    }
}
5. Bundle清单
csharp

// Runtime/Bundle/BundleManifest.cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace LWAssets
{
    /// <summary>
    /// Bundle清单
    /// </summary>
    [Serializable]
    public class BundleManifest
    {
        /// <summary>
        /// 版本号
        /// </summary>
        public string Version;
        
        /// <summary>
        /// 构建时间
        /// </summary>
        public string BuildTime;
        
        /// <summary>
        /// 平台
        /// </summary>
        public string Platform;
        
        /// <summary>
        /// Bundle列表
        /// </summary>
        public List<BundleInfo> Bundles = new List<BundleInfo>();
        
        /// <summary>
        /// 资源映射（资源路径 -> 资源信息）
        /// </summary>
        public List<AssetInfo> Assets = new List<AssetInfo>();
        
        // 运行时使用的字典缓存
        [NonSerialized] private Dictionary<string, BundleInfo> _bundleDict;
        [NonSerialized] private Dictionary<string, AssetInfo> _assetDict;
        [NonSerialized] private Dictionary<string, List<BundleInfo>> _tagBundleDict;
        
        /// <summary>
        /// 构建索引
        /// </summary>
        public void BuildIndex()
        {
            _bundleDict = new Dictionary<string, BundleInfo>();
            _assetDict = new Dictionary<string, AssetInfo>();
            _tagBundleDict = new Dictionary<string, List<BundleInfo>>();
            
            foreach (var bundle in Bundles)
            {
                _bundleDict[bundle.BundleName] = bundle;
                
                foreach (var tag in bundle.Tags)
                {
                    if (!_tagBundleDict.TryGetValue(tag, out var list))
                    {
                        list = new List<BundleInfo>();
                        _tagBundleDict[tag] = list;
                    }
                    list.Add(bundle);
                }
            }
            
            foreach (var asset in Assets)
            {
                _assetDict[asset.AssetPath] = asset;
            }
        }
        
        /// <summary>
        /// 获取Bundle信息
        /// </summary>
        public BundleInfo GetBundleInfo(string bundleName)
        {
            if (_bundleDict == null) BuildIndex();
            return _bundleDict.TryGetValue(bundleName, out var info) ? info : null;
        }
        
        /// <summary>
        /// 获取资源信息
        /// </summary>
        public AssetInfo GetAssetInfo(string assetPath)
        {
            if (_assetDict == null) BuildIndex();
            return _assetDict.TryGetValue(assetPath, out var info) ? info : null;
        }
        
        /// <summary>
        /// 获取资源所在的Bundle
        /// </summary>
        public BundleInfo GetBundleByAsset(string assetPath)
        {
            var assetInfo = GetAssetInfo(assetPath);
            if (assetInfo == null) return null;
            return GetBundleInfo(assetInfo.BundleName);
        }
        
        /// <summary>
        /// 获取指定标签的所有Bundle
        /// </summary>
        public List<BundleInfo> GetBundlesByTag(string tag)
        {
            if (_tagBundleDict == null) BuildIndex();
            return _tagBundleDict.TryGetValue(tag, out var list) ? list : new List<BundleInfo>();
        }
        
        /// <summary>
        /// 获取所有Bundle的依赖（递归）
        /// </summary>
        public List<BundleInfo> GetAllDependencies(string bundleName)
        {
            var result = new List<BundleInfo>();
            var visited = new HashSet<string>();
            
            CollectDependencies(bundleName, result, visited);
            
            return result;
        }
        
        private void CollectDependencies(string bundleName, List<BundleInfo> result, HashSet<string> visited)
        {
            if (visited.Contains(bundleName)) return;
            visited.Add(bundleName);
            
            var bundle = GetBundleInfo(bundleName);
            if (bundle == null) return;
            
            foreach (var depName in bundle.Dependencies)
            {
                var depBundle = GetBundleInfo(depName);
                if (depBundle != null && !result.Contains(depBundle))
                {
                    result.Add(depBundle);
                    CollectDependencies(depName, result, visited);
                }
            }
        }
        
        /// <summary>
        /// 计算所有Bundle总大小
        /// </summary>
        public long GetTotalSize()
        {
            return Bundles.Sum(b => b.Size);
        }
        
        /// <summary>
        /// 计算指定标签Bundle的总大小
        /// </summary>
        public long GetSizeByTag(string tag)
        {
            return GetBundlesByTag(tag).Sum(b => b.Size);
        }
        
        /// <summary>
        /// 序列化为JSON
        /// </summary>
        public string ToJson()
        {
            return JsonUtility.ToJson(this, true);
        }
        
        /// <summary>
        /// 从JSON反序列化
        /// </summary>
        public static BundleManifest FromJson(string json)
        {
            var manifest = JsonUtility.FromJson<BundleManifest>(json);
            manifest.BuildIndex();
            return manifest;
        }
    }
}
6. 加载器接口与基类
csharp

// Runtime/Loader/IAssetLoader.cs
using System;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace LWAssets
{
    /// <summary>
    /// 资源加载器接口
    /// </summary>
    public interface IAssetLoader : IDisposable
    {
        /// <summary>
        /// 初始化
        /// </summary>
        UniTask InitializeAsync(BundleManifest manifest);
        
        #region 同步加载
        
        T LoadAsset<T>(string assetPath) where T : UnityEngine.Object;
        AssetHandle<T> LoadAssetWithHandle<T>(string assetPath) where T : UnityEngine.Object;
        byte[] LoadRawFile(string assetPath);
        string LoadRawFileText(string assetPath);
        
        #endregion
        
        #region 异步加载
        
        UniTask<T> LoadAssetAsync<T>(string assetPath, CancellationToken cancellationToken = default) 
            where T : UnityEngine.Object;
        UniTask<AssetHandle<T>> LoadAssetWithHandleAsync<T>(string assetPath, CancellationToken cancellationToken = default) 
            where T : UnityEngine.Object;
        UniTask<byte[]> LoadRawFileAsync(string assetPath, CancellationToken cancellationToken = default);
        UniTask<string> LoadRawFileTextAsync(string assetPath, CancellationToken cancellationToken = default);
        UniTask<SceneHandle> LoadSceneAsync(string scenePath, LoadSceneMode mode, bool activateOnLoad, 
            CancellationToken cancellationToken = default);
        
        #endregion
        
        #region 资源管理
        
        void Release(UnityEngine.Object asset);
        UniTask UnloadUnusedAssetsAsync();
        void ForceUnloadAll();
        
        #endregion
    }
}

// Runtime/Loader/AssetLoaderBase.cs
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace LWAssets
{
    /// <summary>
    /// 加载器基类
    /// </summary>
    public abstract class AssetLoaderBase : IAssetLoader
    {
        protected LWAssetsConfig _config;
        protected BundleManifest _manifest;
        
        // Bundle缓存
        protected readonly Dictionary<string, BundleHandle> _bundleCache = new Dictionary<string, BundleHandle>();
        // 资源引用计数
        protected readonly Dictionary<UnityEngine.Object, string> _assetRefMap = new Dictionary<UnityEngine.Object, string>();
        // 加载中的Bundle
        protected readonly Dictionary<string, UniTask<BundleHandle>> _loadingBundles = new Dictionary<string, UniTask<BundleHandle>>();
        
        protected readonly object _lockObj = new object();
        
        public AssetLoaderBase(LWAssetsConfig config)
        {
            _config = config;
        }
        
        public abstract UniTask InitializeAsync(BundleManifest manifest);
        
        #region 同步加载 - 默认实现（阻塞等待异步）
        
        public virtual T LoadAsset<T>(string assetPath) where T : UnityEngine.Object
        {
            // 注意：同步加载在某些平台可能导致问题
            return LoadAssetAsync<T>(assetPath).GetAwaiter().GetResult();
        }
        
        public virtual AssetHandle<T> LoadAssetWithHandle<T>(string assetPath) where T : UnityEngine.Object
        {
            return LoadAssetWithHandleAsync<T>(assetPath).GetAwaiter().GetResult();
        }
        
        public virtual byte[] LoadRawFile(string assetPath)
        {
            return LoadRawFileAsync(assetPath).GetAwaiter().GetResult();
        }
        
        public virtual string LoadRawFileText(string assetPath)
        {
            return LoadRawFileTextAsync(assetPath).GetAwaiter().GetResult();
        }
        
        #endregion
        
        #region 异步加载
        
        public abstract UniTask<T> LoadAssetAsync<T>(string assetPath, CancellationToken cancellationToken = default) 
            where T : UnityEngine.Object;
        
        public abstract UniTask<AssetHandle<T>> LoadAssetWithHandleAsync<T>(string assetPath, 
            CancellationToken cancellationToken = default) where T : UnityEngine.Object;
        
        public abstract UniTask<byte[]> LoadRawFileAsync(string assetPath, CancellationToken cancellationToken = default);
        
        public async UniTask<string> LoadRawFileTextAsync(string assetPath, CancellationToken cancellationToken = default)
        {
            var data = await LoadRawFileAsync(assetPath, cancellationToken);
            return data != null ? System.Text.Encoding.UTF8.GetString(data) : null;
        }
        
        public abstract UniTask<SceneHandle> LoadSceneAsync(string scenePath, LoadSceneMode mode, bool activateOnLoad,
            CancellationToken cancellationToken = default);
        
        #endregion
        
        #region Bundle加载
        
        /// <summary>
        /// 加载Bundle及其依赖
        /// </summary>
        protected async UniTask<BundleHandle> LoadBundleAsync(string bundleName, CancellationToken cancellationToken = default)
        {
            // 检查缓存
            lock (_lockObj)
            {
                if (_bundleCache.TryGetValue(bundleName, out var cached))
                {
                    cached.Retain();
                    return cached;
                }
                
                // 检查是否正在加载
                if (_loadingBundles.TryGetValue(bundleName, out var loadingTask))
                {
                    return await loadingTask;
                }
            }
            
            // 创建加载任务
            var task = LoadBundleInternalAsync(bundleName, cancellationToken);
            
            lock (_lockObj)
            {
                _loadingBundles[bundleName] = task;
            }
            
            try
            {
                var handle = await task;
                return handle;
            }
            finally
            {
                lock (_lockObj)
                {
                    _loadingBundles.Remove(bundleName);
                }
            }
        }
        
        /// <summary>
        /// 内部Bundle加载实现
        /// </summary>
        protected virtual async UniTask<BundleHandle> LoadBundleInternalAsync(string bundleName, 
            CancellationToken cancellationToken = default)
        {
            var bundleInfo = _manifest.GetBundleInfo(bundleName);
            if (bundleInfo == null)
            {
                Debug.LogError($"[LWAssets] Bundle not found: {bundleName}");
                return null;
            }
            
            var handle = new BundleHandle(bundleName);
            
            // 先加载依赖
            foreach (var depName in bundleInfo.Dependencies)
            {
                var depHandle = await LoadBundleAsync(depName, cancellationToken);
                handle.AddDependency(depHandle);
            }
            
            // 加载Bundle
            var bundle = await LoadBundleFromSourceAsync(bundleInfo, cancellationToken);
            handle.SetBundle(bundle);
            handle.Retain();
            
            lock (_lockObj)
            {
                _bundleCache[bundleName] = handle;
            }
            
            return handle;
        }
        
        /// <summary>
        /// 从源加载Bundle（子类实现具体逻辑）
        /// </summary>
        protected abstract UniTask<AssetBundle> LoadBundleFromSourceAsync(BundleInfo bundleInfo, 
            CancellationToken cancellationToken = default);
        
        #endregion
        
        #region 资源管理
        
        public virtual void Release(UnityEngine.Object asset)
        {
            if (asset == null) return;
            
            lock (_lockObj)
            {
                if (_assetRefMap.TryGetValue(asset, out var bundleName))
                {
                    _assetRefMap.Remove(asset);
                    
                    if (_bundleCache.TryGetValue(bundleName, out var handle))
                    {
                        handle.Release();
                    }
                }
            }
        }
        
        public virtual async UniTask UnloadUnusedAssetsAsync()
        {
            lock (_lockObj)
            {
                var toRemove = new List<string>();
                
                foreach (var kvp in _bundleCache)
                {
                    if (kvp.Value.ReferenceCount <= 0)
                    {
                        kvp.Value.Dispose();
                        toRemove.Add(kvp.Key);
                    }
                }
                
                foreach (var key in toRemove)
                {
                    _bundleCache.Remove(key);
                }
            }
            
            await UniTask.Yield();
        }
        
        public virtual void ForceUnloadAll()
        {
            lock (_lockObj)
            {
                foreach (var handle in _bundleCache.Values)
                {
                    handle.Dispose();
                }
                _bundleCache.Clear();
                _assetRefMap.Clear();
            }
        }
        
        public virtual void Dispose()
        {
            ForceUnloadAll();
        }
        
        #endregion
        
        #region 工具方法
        
        /// <summary>
        /// 记录资源引用
        /// </summary>
        protected void TrackAsset(UnityEngine.Object asset, string bundleName)
        {
            if (asset == null) return;
            
            lock (_lockObj)
            {
                _assetRefMap[asset] = bundleName;
            }
        }
        
        #endregion
    }
}
7. 编辑器模拟加载器
csharp

// Runtime/Loader/EditorSimulateLoader.cs
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace LWAssets
{
    /// <summary>
    /// 编辑器模拟加载器 - 直接从AssetDatabase加载
    /// </summary>
    public class EditorSimulateLoader : AssetLoaderBase
    {
        public EditorSimulateLoader(LWAssetsConfig config) : base(config)
        {
        }
        
        public override async UniTask InitializeAsync(BundleManifest manifest)
        {
            _manifest = manifest;
            await UniTask.CompletedTask;
            Debug.Log("[LWAssets] EditorSimulateLoader initialized");
        }
        
        #region 同步加载
        
        public override T LoadAsset<T>(string assetPath)
        {
            var asset = AssetDatabase.LoadAssetAtPath<T>(assetPath);
            if (asset == null)
            {
                Debug.LogError($"[LWAssets] Asset not found: {assetPath}");
            }
            return asset;
        }
        
        public override AssetHandle<T> LoadAssetWithHandle<T>(string assetPath)
        {
            var handle = new AssetHandle<T>(assetPath);
            var asset = AssetDatabase.LoadAssetAtPath<T>(assetPath);
            if (asset != null)
            {
                handle.SetAsset(asset);
            }
            else
            {
                handle.SetError(new FileNotFoundException($"Asset not found: {assetPath}"));
            }
            return handle;
        }
        
        public override byte[] LoadRawFile(string assetPath)
        {
            var fullPath = Path.Combine(Application.dataPath.Replace("Assets", ""), assetPath);
            if (File.Exists(fullPath))
            {
                return File.ReadAllBytes(fullPath);
            }
            
            Debug.LogError($"[LWAssets] Raw file not found: {assetPath}");
            return null;
        }
        
        public override string LoadRawFileText(string assetPath)
        {
            var fullPath = Path.Combine(Application.dataPath.Replace("Assets", ""), assetPath);
            if (File.Exists(fullPath))
            {
                return File.ReadAllText(fullPath);
            }
            
            Debug.LogError($"[LWAssets] Raw file not found: {assetPath}");
            return null;
        }
        
        #endregion
        
        #region 异步加载
        
        public override async UniTask<T> LoadAssetAsync<T>(string assetPath, CancellationToken cancellationToken = default)
        {
            // 模拟异步延迟
            await UniTask.Yield(cancellationToken);
            
            var asset = AssetDatabase.LoadAssetAtPath<T>(assetPath);
            if (asset == null)
            {
                Debug.LogError($"[LWAssets] Asset not found: {assetPath}");
            }
            return asset;
        }
        
        public override async UniTask<AssetHandle<T>> LoadAssetWithHandleAsync<T>(string assetPath, 
            CancellationToken cancellationToken = default)
        {
            var handle = new AssetHandle<T>(assetPath);
            
            await UniTask.Yield(cancellationToken);
            
            var asset = AssetDatabase.LoadAssetAtPath<T>(assetPath);
            if (asset != null)
            {
                handle.SetAsset(asset);
            }
            else
            {
                handle.SetError(new FileNotFoundException($"Asset not found: {assetPath}"));
            }
            
            return handle;
        }
        
        public override async UniTask<byte[]> LoadRawFileAsync(string assetPath, CancellationToken cancellationToken = default)
        {
            await UniTask.Yield(cancellationToken);
            return LoadRawFile(assetPath);
        }
        
        public override async UniTask<SceneHandle> LoadSceneAsync(string scenePath, LoadSceneMode mode, 
            bool activateOnLoad, CancellationToken cancellationToken = default)
        {
            var handle = new SceneHandle(scenePath);
            
            try
            {
                var loadParams = new LoadSceneParameters(mode);
                var op = EditorSceneManager.LoadSceneAsyncInPlayMode(scenePath, loadParams);
                
                while (!op.isDone)
                {
                    handle.SetProgress(op.progress);
                    await UniTask.Yield(cancellationToken);
                }
                
                var scene = SceneManager.GetSceneByPath(scenePath);
                handle.SetScene(scene);
            }
            catch (Exception ex)
            {
                handle.SetError(ex);
            }
            
            return handle;
        }
        
        #endregion
        
        protected override UniTask<AssetBundle> LoadBundleFromSourceAsync(BundleInfo bundleInfo, 
            CancellationToken cancellationToken = default)
        {
            // 编辑器模式不需要实际加载Bundle
            return UniTask.FromResult<AssetBundle>(null);
        }
        
        public override void Release(UnityEngine.Object asset)
        {
            // 编辑器模式下不需要特殊处理
        }
        
        public override async UniTask UnloadUnusedAssetsAsync()
        {
            await Resources.UnloadUnusedAssets();
        }
        
        public override void ForceUnloadAll()
        {
            Resources.UnloadUnusedAssets();
        }
    }
    
    /// <summary>
    /// 编辑器清单构建器
    /// </summary>
    public static class EditorManifestBuilder
    {
        public static async UniTask<BundleManifest> BuildAsync()
        {
            var manifest = new BundleManifest
            {
                Version = "0.0.0",
                BuildTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
                Platform = LWAssetsConfig.GetPlatformName()
            };
            
            // 收集所有资源
            var assetPaths = AssetDatabase.GetAllAssetPaths();
            foreach (var path in assetPaths)
            {
                if (!path.StartsWith("Assets/")) continue;
                if (path.EndsWith(".cs") || path.EndsWith(".meta")) continue;
                
                manifest.Assets.Add(new AssetInfo
                {
                    AssetPath = path,
                    AssetType = AssetDatabase.GetMainAssetTypeAtPath(path)?.Name ?? "Unknown",
                    BundleName = "editor_simulate",
                    IsRawFile = IsRawFile(path)
                });
            }
            
            manifest.BuildIndex();
            await UniTask.CompletedTask;
            return manifest;
        }
        
        private static bool IsRawFile(string path)
        {
            var ext = Path.GetExtension(path).ToLower();
            return ext == ".txt" || ext == ".json" || ext == ".xml" || ext == ".bytes" || ext == ".csv";
        }
    }
}
#endif
8. 离线加载器
csharp

// Runtime/Loader/OfflineLoader.cs
using System;
using System.IO;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace LWAssets
{
    /// <summary>
    /// 离线加载器 - 从本地资源包加载
    /// </summary>
    public class OfflineLoader : AssetLoaderBase
    {
        protected CacheManager _cacheManager;
        protected DownloadManager _downloadManager;
        
        public OfflineLoader(LWAssetsConfig config, CacheManager cacheManager, DownloadManager downloadManager) 
            : base(config)
        {
            _cacheManager = cacheManager;
            _downloadManager = downloadManager;
        }
        
        public override async UniTask InitializeAsync(BundleManifest manifest)
        {
            _manifest = manifest;
            await UniTask.CompletedTask;
            Debug.Log("[LWAssets] OfflineLoader initialized");
        }
        
        #region 异步加载实现
        
        public override async UniTask<T> LoadAssetAsync<T>(string assetPath, CancellationToken cancellationToken = default)
        {
            var assetInfo = _manifest.GetAssetInfo(assetPath);
            if (assetInfo == null)
            {
                Debug.LogError($"[LWAssets] Asset not found in manifest: {assetPath}");
                return null;
            }
            
            // 加载Bundle
            var bundleHandle = await LoadBundleAsync(assetInfo.BundleName, cancellationToken);
            if (bundleHandle == null || !bundleHandle.IsValid)
            {
                Debug.LogError($"[LWAssets] Failed to load bundle: {assetInfo.BundleName}");
                return null;
            }
            
            // 从Bundle加载资源
            var assetName = Path.GetFileNameWithoutExtension(assetPath);
            var request = bundleHandle.Bundle.LoadAssetAsync<T>(assetName);
            await request;
            
            var asset = request.asset as T;
            if (asset != null)
            {
                TrackAsset(asset, assetInfo.BundleName);
            }
            
            return asset;
        }
        
        public override async UniTask<AssetHandle<T>> LoadAssetWithHandleAsync<T>(string assetPath, 
            CancellationToken cancellationToken = default)
        {
            var handle = new AssetHandle<T>(assetPath);
            
            try
            {
                var asset = await LoadAssetAsync<T>(assetPath, cancellationToken);
                if (asset != null)
                {
                    handle.SetAsset(asset);
                }
                else
                {
                    handle.SetError(new Exception($"Failed to load asset: {assetPath}"));
                }
            }
            catch (Exception ex)
            {
                handle.SetError(ex);
            }
            
            return handle;
        }
        
        public override async UniTask<byte[]> LoadRawFileAsync(string assetPath, CancellationToken cancellationToken = default)
        {
            var assetInfo = _manifest.GetAssetInfo(assetPath);
            if (assetInfo == null)
            {
                Debug.LogError($"[LWAssets] Raw file not found in manifest: {assetPath}");
                return null;
            }
            
            var bundleInfo = _manifest.GetBundleInfo(assetInfo.BundleName);
            if (bundleInfo == null)
            {
                return null;
            }
            
            var filePath = GetBundlePath(bundleInfo);
            if (!File.Exists(filePath))
            {
                Debug.LogError($"[LWAssets] Raw file not found: {filePath}");
                return null;
            }
            
            // 异步读取文件
            return await File.ReadAllBytesAsync(filePath, cancellationToken);
        }
        
        public override async UniTask<SceneHandle> LoadSceneAsync(string scenePath, LoadSceneMode mode, 
            bool activateOnLoad, CancellationToken cancellationToken = default)
        {
            var handle = new SceneHandle(scenePath);
            
            try
            {
                var assetInfo = _manifest.GetAssetInfo(scenePath);
                if (assetInfo == null)
                {
                    handle.SetError(new FileNotFoundException($"Scene not found: {scenePath}"));
                    return handle;
                }
                
                // 加载场景Bundle
                var bundleHandle = await LoadBundleAsync(assetInfo.BundleName, cancellationToken);
                if (bundleHandle == null || !bundleHandle.IsValid)
                {
                    handle.SetError(new Exception($"Failed to load scene bundle: {assetInfo.BundleName}"));
                    return handle;
                }
                
                // 加载场景
                var sceneName = Path.GetFileNameWithoutExtension(scenePath);
                var op = SceneManager.LoadSceneAsync(sceneName, mode);
                op.allowSceneActivation = activateOnLoad;
                
                while (!op.isDone)
                {
                    handle.SetProgress(op.progress);
                    
                    if (op.progress >= 0.9f && !activateOnLoad)
                    {
                        break;
                    }
                    
                    await UniTask.Yield(cancellationToken);
                }
                
                handle.SetScene(SceneManager.GetSceneByName(sceneName));
            }
            catch (Exception ex)
            {
                handle.SetError(ex);
            }
            
            return handle;
        }
        
        #endregion
        
        #region Bundle加载
        
        protected override async UniTask<AssetBundle> LoadBundleFromSourceAsync(BundleInfo bundleInfo, 
            CancellationToken cancellationToken = default)
        {
            var filePath = GetBundlePath(bundleInfo);
            
            if (!File.Exists(filePath))
            {
                Debug.LogError($"[LWAssets] Bundle file not found: {filePath}");
                return null;
            }
            
            var request = AssetBundle.LoadFromFileAsync(filePath);
            await request;
            
            return request.assetBundle;
        }
        
        /// <summary>
        /// 获取Bundle文件路径
        /// </summary>
        protected virtual string GetBundlePath(BundleInfo bundleInfo)
        {
            // 优先从缓存目录加载
            var cachePath = Path.Combine(_config.GetPersistentDataPath(), bundleInfo.GetFileName());
            if (File.Exists(cachePath))
            {
                return cachePath;
            }
            
            // 其次从StreamingAssets加载
            var streamingPath = Path.Combine(_config.GetStreamingAssetsPath(), bundleInfo.GetFileName());
            return streamingPath;
        }
        
        #endregion
    }
}
9. 联机加载器
csharp

// Runtime/Loader/OnlineLoader.cs
using System;
using System.IO;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace LWAssets
{
    /// <summary>
    /// 联机加载器 - 支持从服务器下载资源
    /// </summary>
    public class OnlineLoader : OfflineLoader
    {
        private VersionManager _versionManager;
        
        public OnlineLoader(LWAssetsConfig config, CacheManager cacheManager, 
            DownloadManager downloadManager, VersionManager versionManager) 
            : base(config, cacheManager, downloadManager)
        {
            _versionManager = versionManager;
        }
        
        public override async UniTask InitializeAsync(BundleManifest manifest)
        {
            _manifest = manifest;
            await UniTask.CompletedTask;
            Debug.Log("[LWAssets] OnlineLoader initialized");
        }
        
        protected override async UniTask<AssetBundle> LoadBundleFromSourceAsync(BundleInfo bundleInfo, 
            CancellationToken cancellationToken = default)
        {
            var filePath = GetBundlePath(bundleInfo);
            
            // 检查是否需要下载
            if (!File.Exists(filePath) || !_cacheManager.ValidateBundle(bundleInfo))
            {
                // 下载Bundle
                await DownloadBundleAsync(bundleInfo, cancellationToken);
            }
            
            // 加载Bundle
            var request = AssetBundle.LoadFromFileAsync(filePath);
            await request;
            
            return request.assetBundle;
        }
        
        /// <summary>
        /// 下载Bundle
        /// </summary>
        private async UniTask DownloadBundleAsync(BundleInfo bundleInfo, CancellationToken cancellationToken = default)
        {
            var url = _config.GetRemoteURL() + bundleInfo.GetFileName();
            var savePath = Path.Combine(_config.GetPersistentDataPath(), bundleInfo.GetFileName());
            
            var task = new DownloadTask
            {
                Url = url,
                SavePath = savePath,
                ExpectedSize = bundleInfo.Size,
                ExpectedHash = bundleInfo.Hash
            };
            
            await _downloadManager.DownloadAsync(new[] { bundleInfo }, null, cancellationToken);
        }
        
        protected override string GetBundlePath(BundleInfo bundleInfo)
        {
            // 优先从缓存目录加载
            var cachePath = Path.Combine(_config.GetPersistentDataPath(), bundleInfo.GetFileName());
            if (File.Exists(cachePath) && _cacheManager.ValidateBundle(bundleInfo))
            {
                return cachePath;
            }
            
            // 其次从StreamingAssets加载
            var streamingPath = Path.Combine(_config.GetStreamingAssetsPath(), bundleInfo.GetFileName());
            if (File.Exists(streamingPath))
            {
                return streamingPath;
            }
            
            return cachePath; // 返回缓存路径，稍后下载
        }
    }
}
10. WebGL加载器
csharp

// Runtime/Loader/WebGLLoader.cs
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.SceneManagement;

namespace LWAssets
{
    /// <summary>
    /// WebGL加载器 - 针对WebGL平台的特殊处理
    /// </summary>
    public class WebGLLoader : AssetLoaderBase
    {
        private CacheManager _cacheManager;
        private DownloadManager _downloadManager;
        
        // WebGL缓存
        private readonly Dictionary<string, byte[]> _webglCache = new Dictionary<string, byte[]>();
        
        public WebGLLoader(LWAssetsConfig config, CacheManager cacheManager, DownloadManager downloadManager) 
            : base(config)
        {
            _cacheManager = cacheManager;
            _downloadManager = downloadManager;
        }
        
        public override async UniTask InitializeAsync(BundleManifest manifest)
        {
            _manifest = manifest;
            await UniTask.CompletedTask;
            Debug.Log("[LWAssets] WebGLLoader initialized");
        }
        
        #region 异步加载实现
        
        public override async UniTask<T> LoadAssetAsync<T>(string assetPath, CancellationToken cancellationToken = default)
        {
            var assetInfo = _manifest.GetAssetInfo(assetPath);
            if (assetInfo == null)
            {
                Debug.LogError($"[LWAssets] Asset not found in manifest: {assetPath}");
                return null;
            }
            
            // 加载Bundle
            var bundleHandle = await LoadBundleAsync(assetInfo.BundleName, cancellationToken);
            if (bundleHandle == null || !bundleHandle.IsValid)
            {
                Debug.LogError($"[LWAssets] Failed to load bundle: {assetInfo.BundleName}");
                return null;
            }
            
            // 从Bundle加载资源
            var assetName = System.IO.Path.GetFileNameWithoutExtension(assetPath);
            var request = bundleHandle.Bundle.LoadAssetAsync<T>(assetName);
            await request;
            
            var asset = request.asset as T;
            if (asset != null)
            {
                TrackAsset(asset, assetInfo.BundleName);
            }
            
            return asset;
        }
        
        public override async UniTask<AssetHandle<T>> LoadAssetWithHandleAsync<T>(string assetPath, 
            CancellationToken cancellationToken = default)
        {
            var handle = new AssetHandle<T>(assetPath);
            
            try
            {
                var asset = await LoadAssetAsync<T>(assetPath, cancellationToken);
                if (asset != null)
                {
                    handle.SetAsset(asset);
                }
                else
                {
                    handle.SetError(new Exception($"Failed to load asset: {assetPath}"));
                }
            }
            catch (Exception ex)
            {
                handle.SetError(ex);
            }
            
            return handle;
        }
        
        public override async UniTask<byte[]> LoadRawFileAsync(string assetPath, CancellationToken cancellationToken = default)
        {
            var assetInfo = _manifest.GetAssetInfo(assetPath);
            if (assetInfo == null)
            {
                Debug.LogError($"[LWAssets] Raw file not found in manifest: {assetPath}");
                return null;
            }
            
            var bundleInfo = _manifest.GetBundleInfo(assetInfo.BundleName);
            if (bundleInfo == null)
            {
                return null;
            }
            
            // WebGL从缓存或远程加载
            var cacheKey = bundleInfo.GetFileName();
            if (_webglCache.TryGetValue(cacheKey, out var cachedData))
            {
                return cachedData;
            }
            
            var url = _config.GetRemoteURL() + bundleInfo.GetFileName();
            using (var request = UnityWebRequest.Get(url))
            {
                await request.SendWebRequest();
                
                if (request.result == UnityWebRequest.Result.Success)
                {
                    var data = request.downloadHandler.data;
                    _webglCache[cacheKey] = data;
                    return data;
                }
                else
                {
                    Debug.LogError($"[LWAssets] Failed to download raw file: {url}, Error: {request.error}");
                    return null;
                }
            }
        }
        
        public override async UniTask<SceneHandle> LoadSceneAsync(string scenePath, LoadSceneMode mode, 
            bool activateOnLoad, CancellationToken cancellationToken = default)
        {
            var handle = new SceneHandle(scenePath);
            
            try
            {
                var assetInfo = _manifest.GetAssetInfo(scenePath);
                if (assetInfo == null)
                {
                    handle.SetError(new System.IO.FileNotFoundException($"Scene not found: {scenePath}"));
                    return handle;
                }
                
                // 加载场景Bundle
                var bundleHandle = await LoadBundleAsync(assetInfo.BundleName, cancellationToken);
                if (bundleHandle == null || !bundleHandle.IsValid)
                {
                    handle.SetError(new Exception($"Failed to load scene bundle: {assetInfo.BundleName}"));
                    return handle;
                }
                
                // 加载场景
                var sceneName = System.IO.Path.GetFileNameWithoutExtension(scenePath);
                var op = SceneManager.LoadSceneAsync(sceneName, mode);
                op.allowSceneActivation = activateOnLoad;
                
                while (!op.isDone)
                {
                    handle.SetProgress(op.progress);
                    
                    if (op.progress >= 0.9f && !activateOnLoad)
                    {
                        break;
                    }
                    
                    await UniTask.Yield(cancellationToken);
                }
                
                handle.SetScene(SceneManager.GetSceneByName(sceneName));
            }
            catch (Exception ex)
            {
                handle.SetError(ex);
            }
            
            return handle;
        }
        
        #endregion
        
        #region Bundle加载
        
        protected override async UniTask<AssetBundle> LoadBundleFromSourceAsync(BundleInfo bundleInfo, 
            CancellationToken cancellationToken = default)
        {
            var url = _config.GetRemoteURL() + bundleInfo.GetFileName();
            
            // WebGL使用UnityWebRequest加载Bundle
            using (var request = UnityWebRequestAssetBundle.GetAssetBundle(url, bundleInfo.CRC))
            {
                await request.SendWebRequest();
                
                if (request.result == UnityWebRequest.Result.Success)
                {
                    return DownloadHandlerAssetBundle.GetContent(request);
                }
                else
                {
                    Debug.LogError($"[LWAssets] Failed to download bundle: {url}, Error: {request.error}");
                    return null;
                }
            }
        }
        
        #endregion
        
        public override void ForceUnloadAll()
        {
            base.ForceUnloadAll();
            _webglCache.Clear();
        }
    }
}
11. 下载管理器
csharp

// Runtime/Download/DownloadManager.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

namespace LWAssets
{
    /// <summary>
    /// 下载进度
    /// </summary>
    public struct DownloadProgress
    {
        public int TotalCount;
        public int




请帮我开发一套完整的Unity3D资源管理系统，命名为LWAssets，专门用于帮助游戏研发团队实现快速部署和高效交付游戏产品。

该系统需要满足以下具体功能需求：

1. 多种运行模式支持

编辑器模拟模式：在Unity编辑器环境中模拟资源加载，便于开发调试

离线模式：从本地资源包加载，适用于正式发布版本

联机模式：从服务器动态下载资源，支持热更新

WebGL模式：针对WebGL平台的特殊优化和兼容性处理

2. 灵活的资源分包策略

按文件夹分包：支持文件夹对资源进行分组打包

按大小分包：根据文件大小自动或手动分配到不同资源包

按优先级分包：区分核心资源和可选资源，实现分级加载

3. 智能下载管理系统

断点续传功能：网络中断后能够从断点继续下载

并发控制：限制同时下载的请求数量，避免网络拥塞

失败重试机制：自动检测下载失败并进行重试，支持重试次数配置

4. 完善的缓存管理系统

版本管理：自动检测资源版本，确保加载最新资源

增量更新：仅下载变化的资源文件，减少下载量

缓存清理：智能管理缓存空间，支持手动和自动清理

5. 资源预加载系统

智能预测：基于用户行为和游戏逻辑预测可能需要的资源

队列管理：合理安排预加载顺序，避免影响当前游戏体验

内存控制：监控内存使用情况，避免内存溢出

6. 加载API设计

支持同步加载：提供传统同步加载接口

支持UniTask异步：提供基于UniTask的异步加载接口

全异步API设计：确保流畅的加载体验，避免UI卡顿

7. 特殊资源处理

原生文件(RawFile)支持：正确处理配置文件、文本文件等原生资源

Shader打包处理：确保Shader在不同平台的正确打包和加载

8. 编辑器工具支持

资源状态分析：在Unity编辑器中显示资源的打包状态和依赖关系

资源查看功能：提供可视化界面查看资源包内容和状态

请确保系统具有良好的扩展性、稳定性和性能表现，能够适应不同规模的游戏项目需求。

Ask followup…




Inputs are processed by third-party AI and responses may be inaccurate.

