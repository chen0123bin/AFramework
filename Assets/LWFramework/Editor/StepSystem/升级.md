Unity大师

参考了 2 个上下文

2/2 已完成

梳理StepNode的Action执行与完成判定模型

给出串行/并行两种模式的设计建议

你要的“Node 下真正并行”，核心是把 StepNode 从“单指针串行队列”升级为“ 多 Action 并发调度器 ”。下面给你一套比较稳、后期扩展成本低的思路（不写代码，只讲设计）。

现状问题定位

- 现在 StepNode 只有 m_CurrentActionIndex ，每帧只 Update() 一个 Action， IsFinished 才切下一个，所以天然只能串行 StepNode.cs 。
- 如果你未来做“持续移动 Action”（需要多帧 Update 才结束），那“边播边动”就不能靠“音频 Action 立刻 Finish”这种技巧了，必须 Node 级并行。
## 思路 1（推荐）：Phase（阶段）+ 组内并行 的 Node 调度模型
把 Node 的 Action 列表从“线性顺序”提升为“多个阶段（phase），每个阶段内并行执行多个 action”。

- 数据结构（概念）
  
  - Node 有 phase0/phase1/phase2...
  - 每个 phase 里是一组 actions，同 phase 的 actions 同时 Enter、同时 Update
  - phase 的推进规则：当前 phase 满足“完成策略”后，进入下一 phase
- 完成策略（每个 phase 可配置）
  
  - WaitAll ：该 phase 内所有 action 结束才进入下一 phase（适合“播完再动”这种严格同步）
  - WaitAny ：任一 action 结束就推进（适合“等点击/等条件满足后进入下一段”，剩余 action 要不要强制退出由策略决定）
  - 还可以扩展： WaitAllBlocking （只等待标记为 blocking 的 action）
- 你提的两种模式如何表达
  
  - “音频播完再移动”：音频 action 和移动 action 放不同 phase，例如 phase0: PlayAudio(wait=true) ， phase1: MoveObject
  - “边播边动”：放同一 phase，例如 phase0: PlayAudio(wait=false 或 wait=true都行，但通常非阻塞) + MoveObject
这个模型的优点：

- 能覆盖“持续移动”“持续跟随”“等待交互”等多帧动作
- 又不需要引入复杂的 action DAG，编辑和理解成本低
- 兼容你现在的 XML 列表结构：只需要给 action 增加一个 phase （或 group ）参数
## 思路 2：Node 内 Action DAG（依赖图）
如果你预计未来不是“阶段”这么线性，而是复杂依赖（A+B 完成后触发 C，D 独立进行），那就用 DAG：

- 每个 Action 变成一个“任务节点”
- XML 里描述依赖关系： depends="action1,action2"
- 调度器每帧启动“依赖已满足且未启动”的任务，Update 所有运行中的任务
- Node 完成条件：WaitAll / WaitAny / 按标记等待
优点是表达力最强；缺点是编辑器复杂度、校验复杂度、理解成本都会显著上升。多数教学/流程类步骤其实不需要到这一步，所以我一般建议先上 Phase 模型 ，不够再升级到 DAG。

## 并行 Node 必须提前统一的“规则”（否则后面会很痛）
不写代码也得先定这几个行为，否则并行跑起来会出现“残留播放”“重复 apply”等边界问题：

1. Node 的完成定义
- 默认建议：Node 完成 = “当前 phase 的等待条件满足，且没有下一 phase”
- 但还要支持：只等待 blocking actions（例如背景音/循环特效不阻塞步骤）
2. Leave 时如何处理未完成的并行 Action
- 现在 Leave 只 Exit 当前 Action；并行后要明确：
  - 离开 Node 时是否强制 Exit 所有已 Enter 的 actions？
  - Exit 是否意味着“取消/停止”（比如移动停止、音频 Stop）还是只是生命周期结束？
- 建议：给 action 一个可选策略： stopOnExit / cancelOnExit ，由具体 action 决定默认行为
3. Jump/Forward 的 ApplyRemaining 语义
- 现在跳转补齐会 ApplyRemaining ，并行后要统一：
  - ApplyRemaining 是“把剩余动作直接 Apply 到最终状态”，还是“只补齐上下文不做表现”？
- 对持续移动这种 action，OnApply 需要定义成“瞬移到目标”还是“设置状态为完成但不改变 transform”（两者都可能合理，要看你的教学需求）
4. ActionChanged 事件怎么定义
- 现在 StepManager 用“当前 action index”来推事件；并行后“当前 action”不再唯一。
- 需要换成更合适的事件语义：
  - OnActionEnter(nodeId, actionIndex/type)
  - OnActionExit(...)
  - 或 OnRunningActionsChanged(nodeId) （由 UI 自己拉取列表）
## XML/编辑器层面的最小表达（给你一个落地方向）
在不改动太大结构的前提下，建议：

- <action type="..."> 下加两个可选属性/param：
  - phase （int，默认按列表顺序递增相当于串行）
  - isBlocking （bool，默认 true）
- Node 内的 actions 仍是一个 list，但运行时按 phase 分组执行
这样：

- 不写 phase = 保持你现在串行行为（兼容老数据）
- 写同 phase = 并行
- phase 不同 = 分阶段串行（组内并行）
结论建议

- 你要“Node 级真正并行”，我建议优先上 Phase + WaitAll/WaitAny + isBlocking 的调度模型：实现成本可控、编辑器改动可控、能覆盖持续移动等长期行为。
- 等你们真的出现“复杂依赖网状结构”再升级为 Action DAG，不要一开始就把系统复杂化。
如果你认可 Phase 模型，下一步我们先把上面 4 条规则（完成/离开/补齐/事件）逐条定下来，避免后面返工。