# 参考：Manus 上下文工程原则

本技能基于 Manus 的上下文工程原则。Manus 是一家 AI 代理公司，已于 2025 年 12 月被 Meta 以 20 亿美元收购。

## Manus 的 6 条原则

### 原则 1：围绕 KV-Cache 设计

> “KV-cache 命中率是生产级 AI 代理最重要的指标。”

**统计：**
- 约 100:1 的输入/输出 token 比例
- 缓存 token：$0.30/百万 token；未缓存：$3/百万 token
- 成本相差 10 倍

**实现要点：**
- 保持 prompt 前缀稳定（单 token 改变会导致缓存失效）
- 系统提示中不要包含时间戳
- 上下文采用只追加（APPEND-ONLY）且序列化可确定

### 原则 2：遮罩而非移除

不要动态移除工具（会破坏 KV-cache），改用 logit 遮罩。

**最佳实践：** 使用一致的动作前缀（如 `browser_`、`shell_`、`file_`）便于遮罩。

### 原则 3：文件系统作为外部记忆

> “Markdown 是我在磁盘上的‘工作记忆’。”

**公式：**
```
上下文窗口 = RAM（易失、有限）
文件系统 = 磁盘（持久、无限）
```

**压缩必须可恢复：**
- 即便丢弃网页正文，也要保留 URL
- 即便丢弃文档内容，也要保留文件路径
- 永远不丢失指向完整数据的指针

### 原则 4：通过复述操控注意力

> “在任务过程中创建并更新 todo.md，把全局计划推入模型最近注意范围。”

**问题：** 约 50 次工具调用后，模型会忘记最初目标（“中间遗失”效应）。

**解决：** 每次决策前重读 `task_plan.md`，把目标重新拉回注意窗口。

```
上下文开始：[最初目标——很远，已被遗忘]
...许多工具调用...
上下文末尾：[刚读过的 task_plan.md —— 获得注意力]
```

### 原则 5：保留错误路径

> “把走错的路保留在上下文中。”

**原因：**
- 带堆栈的失败动作可让模型隐式更新信念
- 降低重复犯错
- 错误恢复是“真正代理行为最清晰的信号之一”

### 原则 6：避免少样本诱导

> “一致性会导致脆弱。”

**问题：** 重复的动作—观察对会引发漂移与幻觉。

**解决：** 引入可控变化：
- 轻微变化措辞
- 不要盲目复制粘贴模式
- 对重复任务进行重新校准

---

## 三种上下文工程策略

基于 Lance Martin 对 Manus 架构的分析。

### 策略 1：上下文缩减

**压缩（Compaction）：**
```
工具调用有两种表示：
├── FULL：原始工具内容（存入文件系统）
└── COMPACT：仅保留引用/路径

规则：
- 对陈旧（较旧）结果执行压缩
- 保留近期结果为 FULL（用于指导下一步决策）
```

**摘要（Summarization）：**
- 当压缩收益递减时启用
- 基于完整工具结果生成
- 产出标准化摘要对象

### 策略 2：上下文隔离（多智能体）

**架构：**
```
┌─────────────────────────────────┐
│          规划智能体             │
│  └─ 向子智能体分配任务          │
├─────────────────────────────────┤
│          知识管理者             │
│  └─ 审阅对话                    │
│  └─ 决定文件系统存储内容        │
├─────────────────────────────────┤
│          执行子智能体           │
│  └─ 执行分配任务                │
│  └─ 拥有独立上下文窗口          │
└─────────────────────────────────┘
```

**关键洞察：** Manus 最初用 `todo.md` 做任务规划，但发现约 33% 的动作都用于更新它。后转为专用规划智能体调用执行子智能体。

### 策略 3：上下文卸载

**工具设计：**
- 原子函数总数 < 20
- 完整结果存入文件系统，不放入上下文
- 使用 `glob` 与 `grep` 检索
- 采用渐进式加载：只在需要时读入信息

---

## 代理循环

Manus 按 7 步循环运行：

```
┌─────────────────────────────────────────┐
│  1. 分析上下文                          │
│     - 理解用户意图                      │
│     - 评估当前状态                      │
│     - 回顾最近观察                      │
├─────────────────────────────────────────┤
│  2. 思考                                │
│     - 是否需要更新计划？                │
│     - 下一步最合理动作？                │
│     - 是否存在阻塞？                    │
├─────────────────────────────────────────┤
│  3. 选择工具                            │
│     - 选择一个工具                      │
│     - 确保参数可用                      │
├─────────────────────────────────────────┤
│  4. 执行动作                            │
│     - 工具在沙箱中执行                  │
├─────────────────────────────────────────┤
│  5. 接收观察                            │
│     - 结果追加到上下文                  │
├─────────────────────────────────────────┤
│  6. 迭代                                │
│     - 回到步骤 1                        │
│     - 直到完成                          │
├─────────────────────────────────────────┤
│  7. 交付结果                            │
│     - 向用户发送结果                    │
│     - 附上所有相关文件                  │
└─────────────────────────────────────────┘
```

---

## Manus 产生的文件类型

| 文件 | 用途 | 创建时机 | 更新时机 |
|------|---------|--------------|--------------|
| `task_plan.md` | 阶段跟踪与进度 | 任务开始 | 完成阶段后 |
| `findings.md` | 发现与决策 | 每次发现后 | 查看图片/PDF 后 |
| `progress.md` | 会话日志与完成情况 | 关键节点 | 全程更新 |
| 代码文件 | 实现 | 执行前 | 出错后 |

---

## 关键约束

- **单动作执行：** 每轮只调用一个工具，不并行。
- **计划必需：** 代理必须始终知道目标、当前阶段、剩余阶段。
- **文件即记忆：** 上下文 = 易失；文件系统 = 持久。
- **不重复失败：** 如果动作失败，下一步必须不同。
- **沟通也是工具：** 消息类型：`info`（进度）、`ask`（阻塞）、`result`（终结）。

---

## Manus 统计数据

| 指标 | 数值 |
|--------|-------|
| 每任务平均工具调用数 | ~50 |
| 输入/输出 token 比例 | 100:1 |
| 收购价格 | 20 亿美元 |
| 达到 1 亿美元收入时间 | 8 个月 |
| 框架重构次数 | 5 次 |

---

## 关键引用

> “上下文窗口 = RAM（易失、有限）。文件系统 = 磁盘（持久、无限）。任何重要信息都写入磁盘。”

> “if action_failed: next_action != same_action. 记录已尝试内容，并调整方案。”

> “错误恢复是最清晰的真正代理行为信号之一。”

> “KV-cache 命中率是生产级 AI 代理最重要的指标。”

> “把走错的路保留在上下文中。”

---

## 来源

基于 Manus 官方上下文工程文档：
https://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus
